#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0)
	#define debug 
#else 
	#define debug(x)	cout << #x << " = " << x << "\n"
#endif

class Aircraft
{
public:
	string nearMiss(vector <int> p1, vector <int> v1, vector <int> p2, vector <int> v2, int R);
};

//int64 sq(int64 a) { return a*a; }
long double sq(long double a) { return a*a;  }

struct Vector {
//	int64 x, y, z;
	long double x, y, z;
//	Vector(int64 a, int64 b, int64 c): x(a), y(b), z(c) { /*cout << "Constructor with arguments (a, b, c).\n";*/ }
	Vector(long double a, long double b, long double c): x(a), y(b), z(c) { /*cout << "Constructor with arguments (a, b, c).\n";*/ }
	Vector(){}
	Vector operator + (const Vector &ob) { return Vector(x+ob.x, y+ob.y, z+ob.z); }
	Vector operator - (const Vector &ob) { return Vector(x-ob.x, y-ob.y, z-ob.z); }
	Vector operator * (const long double &a) { return Vector(x*a, y*a, z*a); }

	void print() {
		printf("(%Lf, %Lf, %Lf) ", x, y, z);
	}
};


long double dist(const Vector &a, const Vector &b) {
	 return sq(a.x-b.x) + sq(a.y-b.y) + sq(a.z-b.z); 
}

int64 R;
Vector p1, p2, v1, v2;

string Aircraft::nearMiss (vector <int> _p1, vector <int> _v1, vector <int> _p2, vector <int> _v2, int _R) 
{
	R = sq((int64)_R);
	p1 = Vector(_p1[0], _p1[1], _p1[2]);
	v1 = Vector(_v1[0], _v1[1], _v1[2]);
	p2 = Vector(_p2[0], _p2[1], _p2[2]);
	v2 = Vector(_v2[0], _v2[1], _v2[2]);

	p1.print();
	v1.print();
	cout << endl;
	p2.print();
	v2.print();
	cout << endl;

	debug(R);

	long double l = 0, r = 10000000;

	forn(lp, 100000) {
		long double t1 = l + (r-l)/3, t2 = l + 2*(r-l)/3;
		long double d1 = dist(Vector(p1 + v1*t1), Vector(p2 + v2*t1));
		long double d2 = dist(Vector(p1 + v1*t2), Vector(p2 + v2*t2));

		if(d2 < d1)
			l = l + (r-l)/3;
		else if(d2 > d1)
			r = l + 2*(r-l)/3;
		else if(d1 == d2) {
			l = l + (r-l)/3;
			r = l + 2*(r-l)/3;
		}
	}

	long double d = dist(Vector(p1 + v1*r), Vector(p2 + v2*r));
	Pf("l = %.10Lf\n", l);
	Pf("r = %.10Lf\n", r);
	Pf("d = %.10Lf\n", d);

	if(d <= R+1e-9)
		return "YES";
	else
		return "NO";

	return "-";
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, vector <int> p3, int p4, bool hasAnswer, string p5) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}" << "," << p4;
	cout << "]" << endl;
	Aircraft *obj;
	string answer;
	obj = new Aircraft();
	clock_t startTime = clock();
	answer = obj->nearMiss(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p5 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p5;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	int p4;
	string p5;
	
	{
	// ----- test 0 -----
	int t0[] = {15,50,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {25,1,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {161,102,9};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-10,-10,-1};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 10;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,2,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {9,0,5};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-2,2,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 5;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-2,2,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {9,0,5};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {2,2,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 5;
	p5 = "NO";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {-2838,-7940,-2936};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,1,-2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {532,3850,9590};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,0,-3};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 3410;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {-8509,9560,345};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-89,-33,62};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {-5185,-1417,2846};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-58,24,26};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 8344;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {-7163,-371,-2459};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-59,-41,-14};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {-2398,-426,-5487};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-43,27,67};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 5410;
	p5 = "NO";
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	int t0[] = {1774,-4491,7810};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-12,19,-24};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {2322,3793,9897};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-12,19,-24};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 10000;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(6, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	int t0[] = {3731,8537,5661};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-70,71,32};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {8701,-1886,-5115};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {28,-13,7};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 9766;
	p5 = "NO";
	all_right = KawigiEdit_RunTest(7, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 8 -----
	int t0[] = {0,1,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {3,-3,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,-1,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {3,3,-3};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 1;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(8, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 9 -----
	int t0[] = {-10000,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {10000,0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,0,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {0,0,0};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 0;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(9, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 10 -----
	int t0[] = {10000,10000,1000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {10000,-10000,10000};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {10000,10000,-1000};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {10000,-10000,-10000};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 2000;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(10, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 11 -----
	int t0[] = {0,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {25,1,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {-10,-10,-1};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 0;
	p5 = "YES";
	all_right = KawigiEdit_RunTest(11, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// In aviation, a "near miss" occurs if the distance between two aircraft at some point in time is less than or equal to some threshold distance R. At a moment in time, the positions and velocities of two aircraft are known exactly. Assuming that each aircraft continues to fly with constant speed and direction, you need to work out if the aircraft will undergo a near miss now or at some point in the future.
// 
// You will be given the threshold distance R and the positions and velocities of the aircraft in 4 vector <int>s: p1, v1, p2 and v2. The position of the first aircraft in 3-D cartesian space is given by (p1[0] , p1[1] , p1[2]) and its velocity vector by (v1[0] , v1[1] , v1[2]) and similarly the second aircraft's position and velocity are given by (p2[0] , p2[1] , p2[2]) and (v2[0] , v2[1] , v2[2]). So, if an aircraft's initial position is the vector p and its velocity vector is v, the position of this aircraft at some future time t will be p + v * t. You should return a String containing "YES" if the aircraft will undergo a near miss now or in the future or "NO" if they won't (quotes for clarity).
// 
// DEFINITION
// Class:Aircraft
// Method:nearMiss
// Parameters:vector <int>, vector <int>, vector <int>, vector <int>, int
// Returns:string
// Method signature:string nearMiss(vector <int> p1, vector <int> v1, vector <int> p2, vector <int> v2, int R)
// 
// 
// NOTES
// -The distance between two points (x1, y1, z1) and (x2, y2, z2) is given by sqrt((x1-x2)2 + (y1-y2)2 + (z1-z2)2).
// 
// 
// CONSTRAINTS
// -p1, v1, p2 and v2 will contain exactly 3 elements.
// -Each element of p1, v1, p2 and v2 will be between -10000 and 10000, inclusive.
// -R will be between 0 and 10000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {15,50,5}
// {25,1,0}
// {161,102,9}
// {-10,-10,-1}
// 10
// 
// Returns: "YES"
// 
// At time 4, the first aircraft will be at position {115,54,5} and the second at {121,62,5}, which is the first point in time at which they are exactly 10 distance units apart.
// 
// 1)
// {0,0,0}
// {2,2,0}
// {9,0,5}
// {-2,2,0}
// 5
// 
// Returns: "YES"
// 
// At time 2.25, aircraft 1 will be at {4.5, 4.5, 0} and aircraft 2 at {4.5, 4.5, 5}, exactly a distance of 5 units apart.
// 
// 2)
// {0,0,0}
// {-2,2,0}
// {9,0,5}
// {2,2,0}
// 5
// 
// Returns: "NO"
// 
// The aircraft are flying away from each other here, so the distance always increases with time.
// 
// 3)
// {-2838,-7940,-2936}
// {1,1,-2}
// {532,3850,9590}
// {1,0,-3}
// 3410
// 
// Returns: "YES"
// 
// The closest approach of the aircraft occurs at time 12,158
// 
// 4)
// {-8509,9560,345}
// {-89,-33,62}
// {-5185,-1417,2846}
// {-58,24,26}
// 8344
// 
// Returns: "YES"
// 
// A near miss occurs between times 111 and 112
// 
// 5)
// {-7163,-371,-2459}
// {-59,-41,-14}
// {-2398,-426,-5487}
// {-43,27,67}
// 5410
// 
// Returns: "NO"
// 
// The aircraft almost have a near miss between times 15 and 16, but stay just outside the threshold distance.
// 
// 6)
// {1774,-4491,7810}
// {-12,19,-24}
// {2322,3793,9897}
// {-12,19,-24}
// 10000
// 
// Returns: "YES"
// 
// The aircraft are here flying with identical velocities, so the distance between them never changes. The distance at time 0 is lower than the threshold, so a near miss is already underway.
// 
// 7)
// {3731,8537,5661}
// {-70,71,32}
// {8701,-1886,-5115}
// {28,-13,7}
// 9766
// 
// Returns: "NO"
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

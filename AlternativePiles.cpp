#include <bits/stdc++.h>
using namespace std;

class AlternativePiles
{
public:
	int count(string C, int M);
};

int AlternativePiles::count (string C, int M)
{
	int ret;
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << p1;
	cout << "]" << endl;
	AlternativePiles *obj;
	int answer;
	obj = new AlternativePiles();
	clock_t startTime = clock();
	answer = obj->count(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	string p0;
	int p1;
	int p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = "WRGWWRGW";
	p1 = 2;
	p2 = 3;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = "RRGG";
	p1 = 1;
	p2 = 0;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = "BBBB";
	p1 = 5;
	p2 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW";
	p1 = 50;
	p2 = 265470435;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = "WRWRGWWGWWWRWBWRWGWWRWBWWRGWBWGRGWWGWGRWGRWBRWBW";
	p1 = 7;
	p2 = 7400348;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Slow loris Guts is playing with N cards, numbered 0 through N-1. Each card has one of four colors: red, green, blue, or white. You are given the card colors as the string C. For each i, character i of C is one of 'R' (red), 'G' (green), 'B' (blue), and 'W' (white).
// 
// You are also given an int M.
// 
// Guts wants to color each white card red, green, or blue in such a way that the number of cards not colored blue is exactly 2*D*M for some non-negative integer D. Additionally, there must be exactly M sequences of integers S_0 through S_{M-1} with the following properties:
// 
// 
// For each i, the sequence S_i contains exactly 2*D integers, each of them between 0 and N-1, inclusive.
// For each i, the sequence S_i is strictly increasing. That is, S_i[0] < S_i[1] < ... < S_i[2*D-1].
// For each i and each even j, the card S_i[j] is red.
// For each i and each odd j, the card S_i[j] is green.
// No two sequences share a common element. Hence, for each index x of a non-blue card there is precisely one pair (i,j) such that S_i[j]=x.
// 
// Return the number of valid ways to color all white cards, modulo 1,000,000,007.
// 
// DEFINITION
// Class:AlternativePiles
// Method:count
// Parameters:string, int
// Returns:int
// Method signature:int count(string C, int M)
// 
// 
// CONSTRAINTS
// -C will contain between 1 and 5,000 characters, inclusive.
// -Each character of C will be 'R', 'G', 'B' or 'W'.
// -M will be between 1 and 50, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "WRGWWRGW"
// 2
// 
// Returns: 3
// 
// There are three valid colorings: "RRGRGRGG", "RRGGRRGG", and "BRGBBRGB".
// 
// For "RRGRGRGG", we have D=2 and one possibility is to select S_0 = {0,2,3,7} and S_1 = {1,4,5,6}.
// 
// For "BRGBBRGB", we have D=1 and to show that this is a valid coloring we let S_0 = {5,6} and S_1 = {1,2}.
// 
// 1)
// "RRGG"
// 1
// 
// Returns: 0
// 
// There is no valid way.
// 
// 2)
// "BBBB"
// 5
// 
// Returns: 1
// 
// Note that D can be zero. Also, note that even though there are no white cards in this test case, there is a valid way to color all white cards: we do nothing and keep the colors we currently have.
// 
// 3)
// "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW"
// 50
// 
// Returns: 265470435
// 
// Do not forget to calculate the answer modulo 10^9 + 7.
// 
// 4)
// "WRWRGWWGWWWRWBWRWGWWRWBWWRGWBWGRGWWGWGRWGRWBRWBW"
// 7
// 
// Returns: 7400348
// 
// 
// 
// END KAWIGIEDIT TESTING

#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	cl(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0)
	#define debug 
#else 
	#define debug(x)	cout << #x << " = " << x << "\n"
#endif

class ArcadeManao
{
public:
	int shortestLadder(vector <string> level, int coinRow, int coinColumn);
};

int N, M;
bool vis[55][55];
vs level;
int row, col;

bool valid(int x, int y) {
	return x >= 0 && x < N && y >= 0 && y < M && level[x][y] == 'X';
}

void dfs(int x, int y, int l=0) {
//	Pf("(%d, %d) ", x, y);
//	debug("#1");
	if(!valid(x, y))
		return;
//	debug("#2");
	if(vis[x][y])
		return;
//	debug("#3");
	vis[x][y] = true;
	dfs(x, y+1, l);
	dfs(x, y-1, l);
	forab(i, 1, l) {
		dfs(x+i, y, l);
		dfs(x-i, y, l);
	}
}

int ArcadeManao::shortestLadder (vector <string> _level, int coinRow, int coinColumn) 
{
	row = coinRow - 1;
	col = coinColumn-1;
	level = _level;
	N = level.size(), M = level.front().size();

	forn(i, 55) {
		cl(vis, 0);
		dfs(N-1, 0, i);
//		cout << endl;
		if(vis[row][col])
			return i;
	}

	return -1;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1 << "," << p2;
	cout << "]" << endl;
	ArcadeManao *obj;
	int answer;
	obj = new ArcadeManao();
	clock_t startTime = clock();
	answer = obj->shortestLadder(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	string t0[] = {"XXXX....","...X.XXX","XXX..X..","......X.","XXXXXXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	p2 = 4;
	p3 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"XXXX","...X","XXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 1;
	p3 = 1;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"..X..",".X.X.","X...X",".X.X.","..X..","XXXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 3;
	p3 = 4;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"X"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 1;
	p3 = 0;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"XXXXXXXXXX","...X......","XXX.......","X.....XXXX","..XXXXX..X",".........X",".........X","XXXXXXXXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 1;
	p3 = 2;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You might remember the old computer arcade games. Here is one about Manao.
// 
// The game level is an NxM grid of equal cells. The bottom of some cells has a platform at which Manao can stand. All the cells in the bottommost row contain a platform, thus covering the whole ground of the level. The rows of the grid are numbered from 1 to N starting from the top and the columns are numbered from 1 to M starting from the left. Exactly one cell contains a coin and Manao needs to obtain it.
// 
// Initially, Manao is standing on the ground, i.e., in the bottommost row. He can move between two horizontally adjacent cells if both contain a platform. Also, Manao has a ladder which he can use to climb. He can use the ladder to climb both up and down. If the ladder is L units long, Manao can climb between two cells (i1, j) and (i2, j) if both contain a platform and |i1-i2| <= L. Note that Manao carries the ladder along, so he can use it multiple times. You need to determine the minimum ladder length L which is sufficient to acquire the coin.
// 
// Take a look at the following picture. On this level, Manao will manage to get the coin with a ladder of length 2.
// 
// 
// 
// You are given a vector <int> level containing N elements. The j-th character in the i-th row of level is 'X' if cell (i+1, j+1) contains a platform and '.' otherwise. You are also given ints coinRow and coinColumn. The coin which Manao seeks is located in cell (coinRow, coinColumn) and it is guaranteed that this cell contains a platform.
// 
// Return the minimum L such that ladder of length L is enough to get the coin. If Manao can perform the task without using the ladder, return 0.
// 
// DEFINITION
// Class:ArcadeManao
// Method:shortestLadder
// Parameters:vector <string>, int, int
// Returns:int
// Method signature:int shortestLadder(vector <string> level, int coinRow, int coinColumn)
// 
// 
// NOTES
// -Manao is not allowed to fall. The only way in which he may change his vertical coordinate is by using the ladder.
// 
// 
// CONSTRAINTS
// -level will contain N elements, where N is between 1 and 50, inclusive.
// -Each element of level will be M characters long, where M is between 1 and 50, inclusive.
// -Each element of level will consist of '.' and 'X' characters only.
// -The last element of level will be entirely filled with 'X'.
// -coinRow will be between 1 and N, inclusive.
// -coinColumn will be between 1 and M, inclusive.
// -level[coinRow - 1][coinColumn - 1] will be 'X'.
// 
// 
// EXAMPLES
// 
// 0)
// {"XXXX....",
//  "...X.XXX",
//  "XXX..X..",
//  "......X.",
//  "XXXXXXXX"}
// 2
// 4
// 
// Returns: 2
// 
// The example from the problem statement.
// 
// 1)
// {"XXXX",
//  "...X",
//  "XXXX"}
// 1
// 1
// 
// Returns: 1
// 
// Manao can use the ladder to climb from the ground to cell (2, 4), then to cell (1, 4) and then he can walk right to the coin.
// 
// 2)
// {"..X..",
//  ".X.X.",
//  "X...X",
//  ".X.X.",
//  "..X..",
//  "XXXXX"}
// 1
// 3
// 
// Returns: 4
// 
// With a ladder of length 4, Manao can first climb to cell (5, 3) and then right to (1, 3).
// 
// 3)
// {"X"}
// 1
// 1
// 
// Returns: 0
// 
// Manao begins in the same cell as the coin.
// 
// 4)
// {"XXXXXXXXXX",
//  "...X......",
//  "XXX.......",
//  "X.....XXXX",
//  "..XXXXX..X",
//  ".........X",
//  ".........X",
//  "XXXXXXXXXX"}
// 1
// 1
// 
// Returns: 2
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class BirthNumbersValidator
{
public:
	vector <string> validate(vector <string> test);
};

bool isLeapYear(int y) {
	return (y%4 == 0 && y % 100 != 0) || (y % 400 == 0);
}

vector <string> BirthNumbersValidator::validate (vector <string> test) 
{
	vector <string> ret;
	string yes = "YES", no = "NO";

	tr(it, test) {
		SS ss(*it);	
		int64 num;
		ss >> num;
		DEBUG(*it);
		if(num % 11 != 0) {
			ret.pb(no);
			DEBUG("#1");
			continue;
		}

		string ys = it->substr(0, 2), ms = it->substr(2, 2), ds = it->substr(4, 2);
		int y = atoi(ys.c_str()), m = atoi(ms.c_str()), d = atoi(ds.c_str());
		DEBUG(y);
		DEBUG(m);
		DEBUG(d);

		if(false)if(y < 1907 || y > 2006) {
			ret.pb(no);
			DEBUG("#2");
			continue;
		}

		if( ! ( (m >= 1 && m <= 12) || (m >= 51 && m <= 62)  ) ) {
			ret.pb(no);
			DEBUG("#3");
			continue;
		}
		if(m > 12)
			m -= 50;

		if(m == 2 || m == 52) {
			if(isLeapYear(y)) {
				if(d < 1 || d > 29) {
					ret.pb(no);
					DEBUG("#4");
					continue;
				}
			}
			else {
				if(d < 1 || d > 28) {
					ret.pb(no);
					DEBUG("#5");
					continue;
				}
			}
		}
// 1, 3, 5, 7,8, 10, 12
		else if( (m < 8 && m % 2 == 1) || (m >= 8 && m % 2 == 0)) {
//		else if (m % 2 == 1) {
			if(d < 1 || d > 31) {
				ret.pb(no);
				DEBUG("#6");
				continue;
			}
		}

		else {
			if(d < 1 || d > 30) {
				ret.pb(no);
				DEBUG("#7");
				continue;
			}
		}
		ret.pb(yes);
		DEBUG("#-7");
	}
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	BirthNumbersValidator *obj;
	vector <string> answer;
	obj = new BirthNumbersValidator();
	clock_t startTime = clock();
	answer = obj->validate(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"8104121234"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"YES"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"8154121239"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"YES"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"8134120005"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"NO"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"8102310007","8104121235"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"NO","NO"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"0411131237"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"YES"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"9708314374"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	all_right = KawigiEdit_RunTest(5, p0, false, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// In Slovakia, every person is assigned a unique 10-digit string when he is born. 
// This string is known as the birth number of the respective person.
// 
// 
// 
// The birth number has the form "YYMMDDCCCC", where:
// 
// 
// 
// YY are the last two digits of the year.
// For males, MM is a two-digit number of the month, i.e., a number between 01 and 12, inclusive.
//     
//     For females, MM is the number of the month increased by 50, i.e., a number between 51 and 62, inclusive.
// DD is a two digit number of the day in the month.
// CCCC are four arbitrary digits that are used both as a checksum and as a way to distinguish between different people born on the same day.
//     
//     The checksum property works as follows: the digits CCCC must be chosen in such a way that the entire 10-digit number is divisible by eleven (11).
//     
// 
// 
// 
// For example, the strings "8104121234" and "8154121239" represent valid birth numbers.
// 
// (The first person is male, the second one female. Both of them are born on April 12th, ??81.)
// 
// 
// 
// The strings "8134120005", "8102310007", and "8104121235" are not valid birth numbers. 
// 
// (In the first case, "34" can not be a valid month. In the second case, the day number is wrong, as the second month has less than 31 days. In the third case, the date is valid but the number is not divisible by 11.)
// 
// 
// 
// You will be given a vector <string> test containing several ten-digit strings. Write a method that will return a vector <string>
// with the same number of elements. If the i-th element of test is a valid birth number the i-th element of the return value shall be "YES",
// otherwise the i-th element of the return value shall be "NO". When checking whether the date is valid, assume that the year when the person was born is between 1907 and 2006, inclusive.
// 
// 
// DEFINITION
// Class:BirthNumbersValidator
// Method:validate
// Parameters:vector <string>
// Returns:vector <string>
// Method signature:vector <string> validate(vector <string> test)
// 
// 
// NOTES
// -The number of days in each month of a non-leap year (from 1 to 12): 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.
// -Leap years have 29 days in the second month.
// -A year is a leap year if either (the year is divisible by 400) or (the year is divisible by 4, but not by 100).  For example, 2000 and 2004 are leap years, 1900 and 1947 are not.
// 
// 
// CONSTRAINTS
// -test will contain between 1 and 50 elements, inclusive.
// -Each element of test will contain exactly 10 characters.
// -Each element of test will contain only digits ('0'-'9').
// 
// 
// EXAMPLES
// 
// 0)
// {"8104121234"}
// 
// Returns: {"YES" }
// 
// The first example from the problem statement.
// 
// 1)
// {"8154121239"}
// 
// Returns: {"YES" }
// 
// The second example from the problem statement.
// 
// 2)
// {"8134120005"}
// 
// Returns: {"NO" }
// 
// The third example from the problem statement.
// 
// 3)
// {"8102310007","8104121235"}
// 
// Returns: {"NO", "NO" }
// 
// The last two examples from the problem statement.
// 
// 4)
// {"0411131237"}
// 
// Returns: {"YES" }
// 
// Note that leading zeros may occur in a valid birth number.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

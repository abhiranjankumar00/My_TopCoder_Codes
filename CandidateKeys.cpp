#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class CandidateKeys
{
public:
	vector <int> getKeys(vector <string> table);
};

int N;
vector <int> keys;
vs table;

inline int getBit(int idx, int n) {
	return ((
	
	n & (1<<idx)) == 0) ? 0 : 1;
}

bool isSubset(int a, int b) {
	forn(i, N)
	       	if(getBit(i,b) == 0)
			if(getBit(i, a) == 1)
				return false;
	return true;
}

bool isSuperKey(int flag) {
	set <string> st;

	tr(it, table) {
		string s = "";
		forn(i, N)	if(getBit(i, flag)) {
			s += it->at(i);
		}
		st.insert(s);
	}
	
	return st.size() == table.size();
}

void print(int n) {
	rep(i, N-1, 0)
		cout << getBit(i, n);
	cout << endl;
}
vector <int> CandidateKeys::getKeys (vector <string> _table) 
{
	table = _table;
	N = table.front().size();
	keys.clear();

	forab(id, 1, (1<<N)-1) {
		if(isSuperKey(id))
			keys.pb(id);
	}

	vector <bool> isCandidate(keys.size(), true);
	forn(i, keys.size())
		forn(j, keys.size())
			if(i != j && isSubset(keys[i], keys[j]))
				isCandidate[j] = false;

	vector <int> ret;
	forn(i, keys.size())	if(isCandidate[i]) {
		if(ret.empty()) {
			ret.pb(100);
			ret.pb(0);
//			ret = {100, 0};
		}
		ret[0] = min(ret[0], __builtin_popcount(keys[i]));
		ret[1] = max(ret[1], __builtin_popcount(keys[i]));
//		print(keys[i]);
	}


	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	CandidateKeys *obj;
	vector <int> answer;
	obj = new CandidateKeys();
	clock_t startTime = clock();
	answer = obj->getKeys(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p1[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <int> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"ABC","ABC","ABC"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"ABC","ABD","ABE"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"ABC","ACD","BBE"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"A","B"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"AABB","BABA","CAAB","DAAA","EBBB","FBBA","GBAB","HBAA"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// A database table consists of a set of columns called attributes, and a set of rows called entries.  A superkey is a set of attributes such that each entry's values for those attributes forms a unique ordered set. That is, for any superkey, each pair of entries differs in at least one of the attributes contained within the superkey.  A candidate superkey is a superkey such that no proper subset of its attributes forms a superkey.
// 
// Return a vector <int> with exactly two elements.  The first element should be the number of attributes in the smallest candidate superkey of the table, and the second element should be the number of attributes in the largest candidate superkey of the table.  If there is no valid candidate superkey, return an empty vector <int> instead.
// 
// The input is described by a vector <string> table.  Each string in table represents one entry, while characters contained in the string are attribute values for that entry.
// 
// DEFINITION
// Class:CandidateKeys
// Method:getKeys
// Parameters:vector <string>
// Returns:vector <int>
// Method signature:vector <int> getKeys(vector <string> table)
// 
// 
// NOTES
// -A proper subset of a superkey is a set of attributes that is formed by removing one or more attributes from the superkey.
// 
// 
// CONSTRAINTS
// -table will contain between 2 and 50 elements, inclusive.
// -Each element of table will contain between 1 and 10 characters, inclusive.
// -Each element of table will contain the same number of characters.
// -Each character in table will be an uppercase letter ('A'-'Z').
// 
// 
// EXAMPLES
// 
// 0)
// {
// "ABC",
// "ABC",
// "ABC"
// }
// 
// Returns: { }
// 
// Since all entries are the same, there is no set of attributes that can differentiate between them.  Therefore, this table has no candidate superkeys.
// 
// 1)
// {
// "ABC",
// "ABD",
// "ABE"
// }
// 
// Returns: {1, 1 }
// 
// There are four superkeys here:
// {column 0, column 1, column 2}
// {column 0, column 2}
// {column 1, column 2}
// {column 2}
// 
// Note that the fourth superkey is a subset of all the other superkeys, so it is the only candidate superkey.
// 
// 
// 2)
// {
// "ABC",
// "ACD",
// "BBE"
// }
// 
// Returns: {1, 2 }
// 
// 
// 
// 3)
// {"A","B"}
// 
// Returns: {1, 1 }
// 
// 
// 
// 4)
// {
// "AABB",
// "BABA",
// "CAAB",
// "DAAA",
// "EBBB",
// "FBBA",
// "GBAB",
// "HBAA"
// }
// 
// Returns: {1, 3 }
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

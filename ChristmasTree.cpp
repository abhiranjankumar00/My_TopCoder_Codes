#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define	forn(i, n)	for(int i = 0; i < n; i++)
#define	forab(i, a, b)	for(int i = a; i <= b; i++)
#define	rep(i, a, b)	for(int i = a; i>=b; i--)

struct Node {
	int n, r, b, g;
	Node(int _n, int _r, int _b, int _g) {
		n = _n,		 r = _r,	b = _b, 	g = _g;
	}
};

bool operator < (const Node & a, const Node & b) {
	if(a.n != b.n)	return a.n < b.n;
	if(a.r != b.r)	return a.r < b.r;
	if(a.b != b.b)	return a.b < b.b;
	return a.g < b.g;
}

int64 fact[15];

int64 Process(int n) {
	return fact[n] = n == 0 ? 1 : n * Process(n-1);
}

map<Node, int64> m;
int N; 

int64 BT(int idx, int R, int B, int G) {
	
	if(idx == N+1)	return 1LL;

	Node node = Node(idx, R, B, G);

	if(present(node, m))
		return m[node];

	m[node] = 0LL;

	if(R >= idx)
		m[node] += BT(idx+1, R - idx, B, G);

	if(B >= idx)
		m[node] += BT(idx + 1, R, B - idx, G);

	if(G >= idx)
		m[node] += BT(idx+1, R, B, G - idx);

	int64 c2 = fact[idx]/(fact[idx/2] * fact[idx/2]), c3 = fact[idx] / (fact[idx/3] * fact[idx/3] * fact[idx/3]); 
	if(idx % 2 == 0) {
		if(R >= idx/2) {
			if(B >= idx/2)
				m[node] += BT(idx + 1, R - idx/2, B - idx/2, G) * c2;
			if(G >= idx/2)
				m[node] += BT(idx + 1, R - idx/2, B, G - idx/2) * c2;
		}
		if(B >= idx/2 && G >= idx/2)
			m[node] += BT(idx + 1, R, B - idx/2, G - idx/2) * c2;
	}

	if(idx % 3 == 0 && R >= idx/3 && B >= idx/3 && G >= idx/3)
		m[node] += BT(idx + 1, R - idx/3, B - idx/3, G - idx/3) * c3;

	assert(m[node] >= 0);

	return m[node];
}

class ChristmasTree
{
public:
	long long decorationWays(int _N, int _r, int _g, int _b)
	{
		m.clear();
		Process(14);
		N = _N;

		return BT(1, _r, _b, _g);
		
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, bool hasAnswer, long long p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3;
	cout << "]" << endl;
	ChristmasTree *obj;
	long long answer;
	obj = new ChristmasTree();
	clock_t startTime = clock();
	answer = obj->decorationWays(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	long long p4;
	
	{
	// ----- test 0 -----
	p0 = 2;
	p1 = 1;
	p2 = 1;
	p3 = 1;
	p4 = 6ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 2;
	p1 = 2;
	p2 = 1;
	p3 = 0;
	p4 = 3ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 3;
	p1 = 2;
	p2 = 2;
	p3 = 1;
	p4 = 0ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 3;
	p1 = 2;
	p2 = 2;
	p3 = 2;
	p4 = 36ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 8;
	p1 = 1;
	p2 = 15;
	p3 = 20;
	p4 = 197121ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are decorating your Christmas tree.  The tree has N levels, numbered 1 through N from top to bottom.  You have a number of red, green and blue baubles, and you've decided to hang them in the following manner: On each level k, you will hang a row of exactly k baubles.  Within each row, you will select the colors of the baubles such that there is an equal number of baubles of each color used in that level.  For example, consider the following two trees:
// 
//       R                 R
//     B   G             B   G 
//   R   R   R         R   B   R
// 
// The tree on the left is correctly decorated.  Each row contains an equal number of baubles for each color used.  The tree on the right, however, is not correctly decorated because the third level contains an unequal number of red and blue baubles.
// 
// 
// 
// You are given an int N, the number of levels in the tree, and ints red, green and blue, representing the number of available baubles in each color.  Return the number of distinct correct ways to decorate the tree.  Two decorated trees are different if there is at least one position at which the two trees have a different colored bauble. If it is impossible to decorate the tree with the given baubles, return 0.
// 
// 
// 
// DEFINITION
// Class:ChristmasTree
// Method:decorationWays
// Parameters:int, int, int, int
// Returns:long long
// Method signature:long long decorationWays(int N, int red, int green, int blue)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 10, inclusive.
// -red will be between 0 and 50, inclusive.
// -green will be between 0 and 50, inclusive.
// -blue will be between 0 and 50, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 1
// 1
// 1
// 
// Returns: 6
// 
// You can use any of the three colors for the top bauble, which always leaves you with two choices for the second level.  Hence, there is a total of six different ways to decorate the tree:
// 
//   R        R  
// B   G    G   B
// 
//   B        B  
// R   G    G   R
// 
//   G        G
// B   R    R   B
// 
// 
// 1)
// 2
// 2
// 1
// 0
// 
// Returns: 3
// 
// If you put the green bauble on the top level, you must put both reds on the second level.  On the other hand, if you put the red bauble on the top level, you have two different ways to decorate the second level (red-green or green-red).  That makes a total of three ways.
// 
// 
// 2)
// 3
// 2
// 2
// 1
// 
// Returns: 0
// 
// You have only five baubles, while six are needed to cover three levels.
// 
// 3)
// 3
// 2
// 2
// 2
// 
// Returns: 36
// 
// The third level must either have three baubles of the same color or three baubles with different colors.  Since you don't have three baubles of the same color, you must use three different colors for that level.
// 
// 4)
// 8
// 1
// 15
// 20
// 
// Returns: 197121
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

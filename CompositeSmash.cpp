#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define	forn(i, n)	for(int i = 0; i < n; i++)
#define	forab(i, a, b)	for(int i = a; i <= b; i++)
#define	rep(i, a, b)	for(int i = a; i>=b; i--)

int a[100010];

class CompositeSmash
{
	int target;

	vi factor(int n) {
		vi ret;
		int i;
		for(i = 2; i*i < n; i++)
			if(n % i == 0)
				ret.pb(i);
		if(i*i == n )
			ret.pb(i);
		return ret;
	}


	int f(int  n) {
		if(n < 0)	return 0;

//		Pf("%d : ", n);

		if(a[n] > -1) ;
//			return a[n];
		else if(n <= target) {
			a[n] = (n == target ? 1 : 0);
//			return a[n];
		}
// fails at N = 24517, target = 23860
		else {
			a[n] = 1;
			vi fact = factor(n);

			if(fact.empty())
				a[n] = 0;

			else 
				tr(it, fact) {
					if( (f(*it) || f(n / (*it)) ) == false)
					{
						a[n] = 0;
						break;
					}
				}
		}
//		Pf("ans = %d\n", a[n]);
		return a[n];
	}

public:
	string thePossible(int N, int _target)
	{
		CL(a, -1);
		target = _target;

		return f(N) ? "Yes" : "No";// fails at N = 24517, target = 23860
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	CompositeSmash *obj;
	string answer;
	obj = new CompositeSmash();
	clock_t startTime = clock();
	answer = obj->thePossible(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = 517;
	p1 = 47;
	p2 = "Yes";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 8;
	p1 = 4;
	p2 = "Yes";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 12;
	p1 = 6;
	p2 = "No";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 5;
	p1 = 8;
	p2 = "No";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 100000;
	p1 = 100000;
	p2 = "Yes";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 5858;
	p1 = 2;
	p2 = "Yes";
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = 81461;
	p1 = 2809;
	p2 = "No";
	all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	p0 = 65536;
	p1 = 256;
	p2 = "No";
	all_right = KawigiEdit_RunTest(7, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 8 -----
	p0 = 24517;
	p1 = 23868;
	p2 = "No";
	all_right = KawigiEdit_RunTest(8, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Toastwoman wants to be a magical girl. As training, she wants to make a ball that contains an integer target.
// 
// 
// Initially she has a ball that contains an integer N. She can smash a ball that contains a composite number (see notes for definition) and break it into two balls. Each new ball will also contain an integer. If she smashes a ball that contains a composite number x and it breaks into two balls that contain y and z, it satisfies y &ge 2, z &ge 2 and yz = x. For example, if she smashes a ball that contains 12, it breaks into 2 and 6 or 3 and 4. Toastwoman can control the ball she smashes, but she can't control the numbers in the two new balls when there are multiple pairs of (y, z) that satisfy the above conditions. She can apply the described ball smash operation arbitrary number of times, but she can't smash a ball that contains a non-composite number.
// 
// 
// If she can always make a ball that contains target, return "Yes" (quotes for clarity). Otherwise, return "No" (quotes for clarity).
// 
// 
// DEFINITION
// Class:CompositeSmash
// Method:thePossible
// Parameters:int, int
// Returns:string
// Method signature:string thePossible(int N, int target)
// 
// 
// NOTES
// -A positive integer x is called a composite number if it has at least one divisor other than 1 and x. For example, 4 and 6 are composite numbers, while 1 and 5 are not composite numbers.
// 
// 
// CONSTRAINTS
// -N will be between 2 and 100,000, inclusive.
// -target will be between 2 and 100,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 517
// 47
// 
// Returns: "Yes"
// 
// If she smashes 517, it breaks into 11 and 47.
// 
// 1)
// 8
// 4
// 
// Returns: "Yes"
// 
// If she smashes 8, it breaks into 2 and 4.
// 
// 2)
// 12
// 6
// 
// Returns: "No"
// 
// If she smashes 12 and it breaks into 3 and 4, she can't make 6.
// 
// 3)
// 5
// 8
// 
// Returns: "No"
// 
// 
// 
// 4)
// 100000
// 100000
// 
// Returns: "Yes"
// 
// She already has target.
// 
// 5)
// 5858
// 2
// 
// Returns: "Yes"
// 
// 
// 
// 6)
// 81461
// 2809
// 
// Returns: "No"
// 
// 
// 
// 7)
// 65536
// 256
// 
// Returns: "No"
// 
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

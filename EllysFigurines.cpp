#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class EllysFigurines
{
public:
	int getMoves(vector <string> board, int R, int C);
};

int setIdx(int idx, int n) {
	return n | (1<<idx);
}
int resetIdx(int idx, int n) {
	return n & (~(1<<idx));
}
int getIdx(int idx, int n) {
	return (n & (1<<idx)) == 0 ? 0 : 1;
}
int flipIdx(int idx, int n) {
	return getIdx(idx, n) == 1 ? resetIdx(idx, n) : setIdx(idx, n);
}

int R, C, N, M;
vs board;

int countSet(set <int> st, int D) {
	int last = -1;
	int ret = 0;
	tr(it, st) {
		if(*it > last) {
			ret++;
			last = *it + D-1;
		}
	}
	return ret;
}

int solve(int flag) {
	set<int> col, row;
	forn(i, 25)
		if(getIdx(i, flag))
			row.insert(i);
	int ret = countSet(row, R);

	forn(i, N)	forn(j, M)	if(board[i][j] == 'X') {
		if(getIdx(i, flag) == 1)
			continue;
		col.insert(j);
	}
	ret += countSet(col, C);
	return ret;
}

int EllysFigurines::getMoves (vector <string> board, int R, int C) 
{
	::R = R, ::C = C, N = board.size(), M = board.front().size();
	::board = board;

	int ret = min(N, M);

	forn(i, 1<<N) {
		ret = min(solve(i),  ret);
	}

	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1 << "," << p2;
	cout << "]" << endl;
	EllysFigurines *obj;
	int answer;
	obj = new EllysFigurines();
	clock_t startTime = clock();
	answer = obj->getMoves(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	string t0[] = {".X.X.","XX..X",".XXX.","...X.",".X.XX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 2;
	p3 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {".X.X.","XX..X",".X.X.","...X.",".X.XX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	p2 = 2;
	p3 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"XXXXXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	p2 = 3;
	p3 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"XXXXX","X....","XXX..","X....","XXXXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 1;
	p3 = 4;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"XXX..XXX..XXX.",".X..X....X...X",".X..X....X...X",".X..X....X...X",".X...XXX..XXX.","..............","...XX...XXX...","....X......X..","....X....XXX..","....X......X..","...XXX..XXX..."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 2;
	p3 = 7;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Elly has placed several (possibly none) figurines on a rectangular board with several rows and columns. Now Kristina wants to remove all figurines from the board. In a single move she selects either up to R consecutive rows, or up to C consecutive columns and removes all remaining figurines that are located there. The girl wonders what is the minimal number of moves in which she can clear the entire board.
// 
// The position of the figurines will be given to you in the vector <string> board. The j-th character of the i-th element of board will be '.' if the cell is empty, or 'X' if it contains a figurine. The maximal number of cleared rows in a single move will be given in the int R. The maximal number of cleared columns in a single move will be given in the int C. Return the minimal number of moves that is sufficient to clear the entire board.
// 
// DEFINITION
// Class:EllysFigurines
// Method:getMoves
// Parameters:vector <string>, int, int
// Returns:int
// Method signature:int getMoves(vector <string> board, int R, int C)
// 
// 
// NOTES
// -In a single move the girl can only select a consecutive group of rows or columns to be cleared. In other words, in each move Kristina first decides whether she wants rows or columns, then she picks the index i of the first chosen row/column, then the number k of chosen rows/columns, and finally she removes all figurines from the rows/columns with indices i, i+1, i+2, ..., i+k-1.
// 
// 
// CONSTRAINTS
// -board will contain between 1 and 15 elements, inclusive.
// -Each element of board will contain between 1 and 15 characters, inclusive.
// -All elements of board will contain the same number of characters.
// -Each character of board will be either '.' or 'X'.
// -R will be between 1 and 15, inclusive.
// -C will be between 1 and 15, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {".X.X.",
//  "XX..X",
//  ".XXX.",
//  "...X.",
//  ".X.XX"}
// 1
// 2
// 
// Returns: 3
// 
// In this case in a single move Elly can remove all figurines from a single row, all figurines from a single column or all figurines from two consecutive columns.
// One way to achieve the optimal answer here would be to remove the figurines from the first and second column in the first move, then the ones from the fourth and fifth column in the second move, and finally the remaining ones on the third row in the third move.
// Another solution would be to erase only columns, again using three moves.
// 
// 1)
// {".X.X.",
//  "XX..X",
//  ".X.X.",
//  "...X.",
//  ".X.XX"}
// 2
// 2
// 
// Returns: 2
// 
// Almost the same as the first example, but without the figurine in the middle and the number of maximal rows removed is increased by one.
// This time, the only optimal solution is to clear the first two columns in one move and the last two in another move.
// 
// 2)
// {"XXXXXXX"}
// 2
// 3
// 
// Returns: 1
// 
// The maximal allowed number of cleared rows or columns might be greater than the corresponding dimension of the board. The optimal solution for this board is to clear the only row in one move.
// 
// 3)
// {"XXXXX",
//  "X....",
//  "XXX..",
//  "X....",
//  "XXXXX"}
// 1
// 1
// 
// Returns: 4
// 
// Here clearing rows 1, 3 and 5, together with column 1 yields the best result 4.
// 
// 4)
// {"XXX..XXX..XXX.",
//  ".X..X....X...X",
//  ".X..X....X...X",
//  ".X..X....X...X",
//  ".X...XXX..XXX.",
//  "..............",
//  "...XX...XXX...",
//  "....X......X..",
//  "....X....XXX..",
//  "....X......X..",
//  "...XXX..XXX..."}
// 1
// 2
// 
// Returns: 7
// 
// Good luck in TCO 13!
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

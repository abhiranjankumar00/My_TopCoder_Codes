#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class EllysReversals
{
public:
	int getMin(vector <string> words);
};

string hakuna(string word) {
	vector <string> subset;
	while(word.size() > 1) {
		string tmp = word.substr(0, 2);
		word = word.substr(2);
		sort(all(tmp));
		subset.pb(tmp);
	}
	sort(all(subset));
	string ret;
	tr(it, subset)
		ret += *it;
	if(word.size() > 0)
		ret += word;
	return ret;
}

int EllysReversals::getMin (vector <string> words) 
{
	map <string, int> m;
	tr(it, words)
		m[hakuna(*it)]++;
 
	int ret = 0;
	tr(it, m) {
	//	cout << it->first << ": " << it->second << endl;
		ret += it->second % 2;
	}
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	EllysReversals *obj;
	int answer;
	obj = new EllysReversals();
	clock_t startTime = clock();
	answer = obj->getMin(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"esprit","god","redotopc","odcpoter","dog"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"no","zaphod","just","very","improbable"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"rats","live","stressed","to","act","as","star","desserts","of","evil","cat","sa","fo","ot"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"topcoder","redocpot","doretopc","cpotdoer","harlemshake"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"iprlzgukfggzg","bmhxvjbrtkbxy","khapjiabbny","nqlwgmcyvdikt","nxromtvtpug","leealcapovm","ushnxwjczczbmd","bwhykzupcux","xrlboyuwlnsp","bbjoketeheezfs","dxfztrldomjqkv","dkbktqdtgfujcut","zfybzyuxgpnt","ffmsldrdftode","vopuufksxd","pqhbsiujwda","yhwbkzupcux","hkbabnapjiy","zqsqefrrzehtxn","yovinyguyudmv"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 16;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"topcoder","redocpot","doretopc","cpotdoer","reodtopc"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	string t0[] = {"aaaababbabbbabbababbabbaaaabbabaaabbaabaaabaaaabab","aabbbaabbbabaabbabaaababaaaaaabbaaaabbaababbabbbbb","bbaabbabbbaabbbaababaaaaaababbaabbbaabababbbabbaba","abaaabbbaaabbbaababbabbbababbabbbaabaaabababaaabab","ababaabbbbbbbaababaaaabbabbabababaaabbbbbaababaaba","abbabbbaabbbabbaabbbbabbbabbababaababaaaaaabaababa","ababbbaabaabaabbabaaaaabaaabaabaabbbbababbaaababaa","baaaababaabaaaabaaabaabbbabbbbbbabaabaabbababbaaaa","bbabaabaabbabbaabaababbbbbabaabababbaaabaaaaababba","ababaabbbaaabbbbabaaabbbbaaaaaabaaabbbaaababaaabba","bbbbbababbabbaaaabbababbabaaaabbbbaabbaaaabaaaabbb","ababaaaabaaabaaaaaaaaabbabababbaabababbbababababba","bbbbabbaaaabaabbabbabbbaaabaababbaabbabbaaaabbbaab","bbbaabbbaabaaababaaaabbbbbaabaabbaaaaabbbaabbbbbaa","aaaaaaaaaaaabaaaaababaaabaababababbaabaababababaab","bbbaaaabbabbabbabbbbabbbbaabbabbbbbbbbbaaabbababbb","bbbbababaaaaabababaababbaaaaabaaaaaaabbbbaabbbbbaa","abababaabbbbbbbbbaabbaabbbbabbabababbababaabaabbba","abababaaaabbbbabbbaabaaaaabbabbabbababbbabbbbb"
			"bbba","abbaabbbababbaaaaaabbbbaaabbbaaaaabaaaabbaabbaabaa","bbaabbaabbaaaabbababbaabbabaaabbaaaabaabbaabbbaabb","abaabaabbabbaabaaabaaaabbbaababbbabbaabbbbaaabaaaa","bababbaabaaabaaababaababbbbabbbbbabbababbababbaaaa","babbbaaaababbaaabbabbabaabaabababaaabbabbbbbaaabba","babaabbbababababababaaaabbbbaaabaaabbabaabaaaaaaaa","baaabaaabaaaabbbabbbaabaaabbabbbbbaabbbaababbbabaa","baabababbabaabbabaaaabbbbabbabbabbabaaabaabbbabbaa","bbabbbbabbbbbbbaaabbaaaabaaaabbaaabaabbbabbaabaaba","abbbbaaaabbabbaaaaabbabaaabbbaababbabbbbbbaaaabbbb","abaaaabbaaababbaaabbbaaaaaabaabbababababaabaabbbaa","bbbaabaaaaaaababaaaaaabaaababbbbaaaaabaabaaaaababa","abbaaaabaabbbbaababaaabaaaaabaaaaaabbbabaaaaababab","abaabbbaabaabaababbbabbaaabbbaaababbababbabbaaabaa","bababbabbbbbbabbbbbababbbaabbaaaaaaaaaabbbaabbbbaa","babaabbaabbaaabbbabbbaabbbbaababbbaaaabbbaaabbbaaa","ababbaabbabbbbaabbbabbbaaaaababaabbbabbbbbabababaa","ababbaaababaaabbbaaabaaabbbababbabbbababbbaabababa","baabaabbabababbabaababbbaaaabbbababbabbb"
			"bbaaababba","babbbbbbbbaaaaabababbaabbbbbaaabbbaaabbbbbaaaababb","aaaaaabbbbaaaabbbbbaaabbaaababbbaaabbaabaaaababbab","baaabbaababbbabaabbbbaaaabaababbbaaabbbabbabbaabab","aabbbabbbbaabaabbabbbabbbbababbbaaababaabaaabbaabb","baabaabbabbaaabbbaaaaabaaaaaaabaaabbbbbbbabbbaaaba","aabbbbbbbabbbaaaabbbbabbbaaaaaaabaabaaabaaaababbba","bbabbaabbabbabbbabaaabbbbbaaababbabbaababbabbbbaab","baabaabaabaabaababaabbbaaaaababbbbabaababaabaabbbb","aaabaaaababaabbbabaaabaaaabbababbbbbaaababbabaaabb","abbabbabababaaaaabbaabbaabbaabbbababbaabbbaabbbbab","abababbbbabbbbabbababaababaabbbbaababbbaabaababbaa","bbbabbbababbabaababbbbabbabbabbbabbabbaaababaabbaa"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 26;
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Elly has a list of several distinct strings given in the vector <string> words. She can apply the following operation as many times as she wants (including zero times):
// 
// Choose one of the words and call it S.
// Choose an even number k between 2 and |S|, inclusive, where |S| is the length of S (thus, chose a prefix with even length).
// Reverse the order of the first k characters of S (thus, reverse the chosen prefix without the rest of the word).
// 
// For example, if she has the word "topcoder", she can reverse its first 2, 4, 6, or all 8 characters. If she chooses to reverse its first 4 characters, the change will be: "topcoder" -> "cpotoder". If at a later time she decides to chose the same string and reverse all of its characters (which is also a valid prefix with even length), she would get "cpotoder"->"redotopc".
// 
// After performing some operations two strings might become equal. If that happens, Elly crosses them out and continues playing her game with the remaining strings only, i.e. they "disappear" from the list. The girl wonders what is the minimal number of strings she can end up with.
// 
// For example, suppose she has the strings {"esprit", "god", "redotopc", "odcpoter", "dog"}. The word "redotopc" can be converted to "topcoder" by first reversing all 8 characters and then reversing the first 4. The word "odcpoter" can also be converted to "topcoder" by performing "odcpoter" -> "docpoter" -> "topcoder". At that point the words become equal and disappear, leaving Elly only with {"esprit", "god", "dog"}. This is where she gets stuck: The words "god" and "dog" cannot become equal, because she can only reverse prefixes with even length. Thus, the minimal number of words she can get is 3.
// 
// Given her initial strings in vector <string> words, return an int indicating the minimal number of strings she can be left with.
// 
// DEFINITION
// Class:EllysReversals
// Method:getMin
// Parameters:vector <string>
// Returns:int
// Method signature:int getMin(vector <string> words)
// 
// 
// CONSTRAINTS
// -words will contain between 1 and 50 elements, inclusive.
// -Each element of words will contain between 1 and 50 characters, inclusive.
// -Each element of words will consist only of lowercase letters of the English alphabet ('a'-'z').
// -All elements of words will be distinct.
// 
// 
// EXAMPLES
// 
// 0)
// {"esprit", "god", "redotopc", "odcpoter", "dog"}
// 
// Returns: 3
// 
// The example from the problem statement.
// 
// 1)
// {"no", "zaphod", "just", "very", "improbable"}
// 
// Returns: 5
// 
// It is possible that she cannot get rid of any of the words.
// 
// 2)
// {"rats", "live", "stressed", "to", "act", "as", "star", "desserts", "of", "evil", "cat", "sa", "fo", "ot"}
// 
// Returns: 0
// 
// It is possible that she ends up with zero words.
// 
// 3)
// {"topcoder", "redocpot", "doretopc", "cpotdoer", "harlemshake"}
// 
// Returns: 1
// 
// Sometimes it is possible to match different words when using a different sequence of operations.
// 
// 4)
// {"iprlzgukfggzg", "bmhxvjbrtkbxy", "khapjiabbny", "nqlwgmcyvdikt",
//  "nxromtvtpug", "leealcapovm", "ushnxwjczczbmd", "bwhykzupcux",
//  "xrlboyuwlnsp", "bbjoketeheezfs", "dxfztrldomjqkv", "dkbktqdtgfujcut",
//  "zfybzyuxgpnt", "ffmsldrdftode", "vopuufksxd", "pqhbsiujwda",
//  "yhwbkzupcux", "hkbabnapjiy", "zqsqefrrzehtxn", "yovinyguyudmv"}
// 
// Returns: 16
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

class EllysXors
{
public:
	long long getXor(long long L, long long R);
};


int64 cnt(int64 a, int64 n) {
	int64 m = n*2ll;

	return (a/m)*n + max(0ll, a%m - n +1);

	return a/m + (a%m >= n ? 1ll : 0ll);
}

long long EllysXors::getXor (long long a, long long b) 
{
// /*
	int64 ans = 0;
	if(a%2 == 1) {
		ans ^=  a;
		a+1;
	}
	if(b%2 == 0) {
		ans ^= b;
		b -= 1;
	}

	ans ^= ((b+1-a)/2)&1;
	return ans;
// */	
	long long ret = 0;
	int idx = 0;

	for(int64 n = 1ll; n <= int64(1e17); n*=2ll, idx++) {
		int64 cnt1 = cnt(a-1, n);
		int64 cnt2 = cnt(b, n);

		if((cnt2 - cnt1)%2 == 1)
			ret |= (1ll<<idx);
	//	cout << ((cnt2 - cnt1)%2);
	}
	//cout << endl;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, long long p1, bool hasAnswer, long long p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	EllysXors *obj;
	long long answer;
	obj = new EllysXors();
	clock_t startTime = clock();
	answer = obj->getXor(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	long long p0;
	long long p1;
	long long p2;
	
	{
	// ----- test 0 -----
	p0 = 3ll;
	p1 = 10ll;
	p2 = 8ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 5ll;
	p1 = 5ll;
	p2 = 5ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 13ll;
	p1 = 42ll;
	p2 = 39ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 666ll;
	p1 = 1337ll;
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 1234567ll;
	p1 = 89101112ll;
	p2 = 89998783ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 281474976710656ll;
	p1 = 281474976710656ll;
	p2 = 281474976710656ll;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = 1ll;
	p1 = 10ll;
	p2 = 11ll;
	all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	p0 = 10001ll;
	p1 = 4000000000ll;
	all_right = KawigiEdit_RunTest(7, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 8 -----
	p0 = 1245ll;
	p1 = 3900000000ll;
	all_right = KawigiEdit_RunTest(8, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// XOR problems became very popular in TopCoder recently. (If you do not know the bitwise operation XOR, see the Notes section for an explanation.) That's why Elly decided to invent one of her own. Fortunately for you, the one she came up with is quite simple. You are given two long longs L and R. She wants you to find the XOR of all numbers between L and R, inclusive.
// 
// DEFINITION
// Class:EllysXors
// Method:getXor
// Parameters:long long, long long
// Returns:long long
// Method signature:long long getXor(long long L, long long R)
// 
// 
// NOTES
// -XOR (exclusive or) is a binary operation, performed on two numbers in binary notation. First, the shorter number is prepended with leading zeroes until both numbers have the same number of digits (in binary). Then, the result is calculated as follows: for each bit where the numbers differ the result has 1 in its binary representation. It has 0 in all other positions.
// -For example 42 XOR 7 is performed as follows. First, the numbers are converted to binary: 42 is 101010 and 7 is 111. Then the shorter number is prepended with leading zeros until both numbers have the same number of digits. This means 7 becomes 000111. Then 101010 XOR 000111 = 101101 (the result has ones only in the positions where the two numbers differ). Then the result can be converted back to decimal notation. In this case 101101 = 45, so 42 XOR 7 = 45.
// -One of the ways to calculate the XOR of more than two numbers A1, A2, ..., An is "A1 XOR (A2 XOR (... XOR An))..))". Since the function is commutative and associative, you can also express it as "A1 XOR A2 XOR ... XOR An" and group the operands in any way you like.
// -It can be proved that the answer is always less than 2*R for the given constraints.
// 
// 
// CONSTRAINTS
// -L and R will be between 1 and 4,000,000,000, inclusive.
// -L will be less than or equal to R.
// 
// 
// EXAMPLES
// 
// 0)
// 3
// 10
// 
// Returns: 8
// 
// 
// ((((((3 XOR 4) XOR 5) XOR 6) XOR 7) XOR 8) XOR 9) XOR 10 =
//         (((((7 XOR 5) XOR 6) XOR 7) XOR 8) XOR 9) XOR 10 = 
//                 ((((2 XOR 6) XOR 7) XOR 8) XOR 9) XOR 10 = 
//                         (((4 XOR 7) XOR 8) XOR 9) XOR 10 = 
//                                 ((3 XOR 8) XOR 9) XOR 10 =
//                                        (11 XOR 9) XOR 10 =
//                                                 2 XOR 10 = 8.
// 
// 
// 1)
// 5
// 5
// 
// Returns: 5
// 
// The XOR of a single number is the number itself.
// 
// 2)
// 13
// 42
// 
// Returns: 39
// 
// A bit larger example.
// 
// 3)
// 666
// 1337
// 
// Returns: 0
// 
// The answer can be zero.
// 
// 4)
// 1234567
// 89101112
// 
// Returns: 89998783
// 
// 
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

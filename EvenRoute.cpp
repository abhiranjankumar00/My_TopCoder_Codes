#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

class EvenRoute
{
public:
	string isItPossible(vector <int> x, vector <int> y, int par)
	{
		bool odd = false, even = false;
		forn(i, x.size())
			if(abs(x[i])%2 + abs(y[i])%2 == 1)
				odd = true;
			else
				even = true;
				
		if(!odd)
			return par == 0 ? "CAN" : "CANNOT";
		
		if(odd && par == 1)
			return "CAN";
			
		if(par == 0)
			if(even)
				return "CAN";
		
		return "CANNOT";
		
//		bool in = false;
/*		
		forn(i, x.size())		if(abs(x[i]) % 2 + abs(y[i]) % 2 == 1) {
			forn(j, x.size())	forn(k, x.size())	if(i != j && i != k && j != k)
				if(x[j] >= x[i] && y[j] >= y[i])
					if(x[k] <= x[i] && y[k] <= y[i])
						in = true;
		}

		if(in && par == 0)
			return "CAN";
*/					
		return "CANNOT";
				
//				return par == 1 ? "CAN" : "CANNOT";
//		return par == 0 ? "CAN" : "CANNOT";
//		string ret;
//		
//		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	EvenRoute *obj;
	string answer;
	obj = new EvenRoute();
	clock_t startTime = clock();
	answer = obj->isItPossible(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	string p3;
	
	{
	// ----- test 0 -----
	int t0[] = {-1,-1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,1,1,-1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	p3 = "CAN";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {-5,-3,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,0,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	p3 = "CAN";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1001,-4000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	p3 = "CAN";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {11,21,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-20,42,7};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	p3 = "CANNOT";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {0,6};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {10,-20};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	p3 = "CANNOT";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Fox Ciel has stumbled upon a new problem: In this problem you will visit some points with integer coordinates in the Cartesian plane. Initially, you are located at the point (0,0). In each step, you can move from your current point to one of the four directly adjacent points.
// I.e., if you are at (x,y), you can move to one of the points (x,y+1), (x,y-1), (x+1,y), and (x-1,y).
// 
// You are given two vector <int>s x and y, each containing N elements.
// Together, x and y describe N distinct points in the Cartesian plane:
// for 0 <= i < N, point i has the coordinates (x[i],y[i]).
// 
// The goal is to find a sequence of steps that satisfies the following criteria:
// The starting point is (0,0).
// The sequence visits each of the N given points at least once.
// The sequence finishes in one of the given points.
// 
// 
// Mr. K claims to have solved this problem but Ciel does not believe him. Ciel has prepared a method to verify Mr. K's claims. Given an int wantedParity, the parity of the number of steps in the sequence found by Mr. K, Ciel will find if it is possible to find a sequence that follows the previously mentioned conditions and a new one:
// 
// The parity of the total number of steps is wantedParity. In other words, if wantedParity=0 then the total number of steps must be even, and if wantedParity=1 then the total number of steps must be odd.
// 
// 
// Return "CAN" (quotes for clarity) if at least one such sequence of steps exists, and "CANNOT" otherwise.
// 
// DEFINITION
// Class:EvenRoute
// Method:isItPossible
// Parameters:vector <int>, vector <int>, int
// Returns:string
// Method signature:string isItPossible(vector <int> x, vector <int> y, int wantedParity)
// 
// 
// CONSTRAINTS
// -wantedParity will be 0 or 1.
// -x will contain between 1 and 50 elements, inclusive.
// -y will contain the same number of elements as x.
// -Each element of x and y will be between -1000000 and 1000000, inclusive.
// -No point in the input will be equal to (0,0).
// -No pair of points in the input will be equal.
// 
// 
// EXAMPLES
// 
// 0)
// {-1,-1,1,1}
// {-1,1,1,-1}
// 0
// 
// Returns: "CAN"
// 
// A possible sequence containing an even number of steps:
// 2 steps: (0,0) -> (-1,-1).
// 2 steps: (-1,-1) -> (-1,1).
// 2 steps: (-1,1) -> (1,1).
// 2 steps: (1,1) -> (1,-1).
// 
// 
// 1)
// {-5,-3,2}
// {2,0,3}
// 1
// 
// Returns: "CAN"
// 
// A possible sequence containing an odd number of steps:
// 
// 7 steps: (0,0) -> (-5,2).
// 4 steps: (-5,2) -> (-3,0).
// 8 steps: (-3,0) -> (2,3).
// 
// 
// 
// 2)
// {1001, -4000}
// {0,0}
// 1
// 
// Returns: "CAN"
// 
// The shortest sequence that visits all the given points is the sequence that first goes to (1001,0) and then to (-4000,0).
// Note that this sequence does not have an odd amount of steps.
// However, there is a longer sequence with an odd number of steps: (0,0) -> (-4000,0) -> (1001, 0).
// 
// 3)
// {11, 21, 0}
// {-20, 42, 7}
// 0
// 
// Returns: "CANNOT"
// 
// 
// 
// 4)
// {0, 6}
// {10, -20}
// 1
// 
// Returns: "CANNOT"
// 
// 
// 
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

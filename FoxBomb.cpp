#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

class FoxBomb
{
public:
	int getMinimumCost(vector <string> grid)
	{
		int ret;
		
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	FoxBomb *obj;
	int answer;
	obj = new FoxBomb();
	clock_t startTime = clock();
	answer = obj->getMinimumCost(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"#...","..##","#.##"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {".#.#.#.",".......",".#.#.#."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"######################################","######################################","###.....................##############","###.###################.###....#...###","###.###################.###.######.###","###.###################.###.######.###","###.###################.###.######.###","###.###################.###.######.###","###.###################.###.######.###","###.........####........###.######.###","###########.###########.###........###","###########.###########.##########.###","###########.###########.##########.###","###########.###########.##########.###","###########.###########.##########.###","##..........##..........##########.###","#######################............###","######################################"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 9;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {".#.","...","#.#","...",".#."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Fox Ciel is playing a game named Bomberfox. The game is played on a rectangular grid divided into 1x1 cells. Each cell is either a wall or a floor. Initially, all the floor is colored white.
// 
// Ciel can place bombs onto floor cells of the field. When a bomb explodes, its blast spreads to four direction - up, down, left and right. In each of the four directions the blast only stops when it hits the wall. When a cell gets hit by a blast, its color turns to red. The purpose of the game is to color all floor cells red by placing as few bombs as possible.
// 
// You are given a vector <string> grid, which represents the grid of the game. The j-th character of the i-th element of grid is '#' if the cell in the j-th column of the i-th row is a wall, and is '.' if the cell is a floor (quotes for clarity). Your method must return the minimum required number of bombs.
// 
// In this problem, there is an additional constraint: the floor cells form a tree. A more formal specification follows: We say that two cells are adjacent when they share an edge. A path from cell A to cell B is a sequence of distinct cells such that the first cell in the sequence is cell A, the last cell is B, and each pair of consecutive cells in the sequence is adjacent. A floor-only path is a path such that all cells in it, including A and B, are floor cells. The test data for this task has the following property: For each pair of floor cells in the grid, there is exactly one floor-only path from one of them to the other.
// 
// 
// DEFINITION
// Class:FoxBomb
// Method:getMinimumCost
// Parameters:vector <string>
// Returns:int
// Method signature:int getMinimumCost(vector <string> grid)
// 
// 
// CONSTRAINTS
// -grid will contain between 1 and 50 elements, inclusive.
// -Each element of grid will contain between 1 and 50 characters, inclusive.
// -All elements of grid will contain the same number of characters.
// -Each character of grid will be either '#' or '.'.
// -grid will contain at least one '.' character.
// -Floor cells of grid will form a tree. See the statement for formal constraints.
// 
// 
// EXAMPLES
// 
// 0)
// {"#..."
// ,"..##"
// ,"#.##"}
// 
// Returns: 2
// 
// In this case, there are multiple optimal solutions. One of the optimal solution is shown below. Here, 'B' represents a cell to which Ciel should place a bomb.
// 
// #.B.
// .B##
// #.##
// 
// 
// 1)
// {".#.#.#."
// ,"......."
// ,".#.#.#."}
// 
// Returns: 4
// 
// One optimal solution is shown below.
// 
// .#.#.#.
// B.B.B.B
// .#.#.#.
// 
// 
// 
// 2)
// {"######################################"
// ,"######################################"
// ,"###.....................##############"
// ,"###.###################.###....#...###"
// ,"###.###################.###.######.###"
// ,"###.###################.###.######.###"
// ,"###.###################.###.######.###"
// ,"###.###################.###.######.###"
// ,"###.###################.###.######.###"
// ,"###.........####........###.######.###"
// ,"###########.###########.###........###"
// ,"###########.###########.##########.###"
// ,"###########.###########.##########.###"
// ,"###########.###########.##########.###"
// ,"###########.###########.##########.###"
// ,"##..........##..........##########.###"
// ,"#######################............###"
// ,"######################################"}
// 
// Returns: 9
// 
// 
// 
// 3)
// {".#."
// ,"..."
// ,"#.#"
// ,"..."
// ,".#."}
// 
// 
// Returns: 5
// 
// 
// 
// 4)
// {"."}
// 
// Returns: 1
// 
// 
// 
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

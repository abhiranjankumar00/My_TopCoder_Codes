#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	cl(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0)
	#define debug 
#else 
	#define debug(x)	cout << #x << " = " << x << "\n"
#endif

class GameOnABoard
{
public:
	int optimalChoice(vector <string> cost);
};

vector <string> cost;
int N, M;
int dist[55][55];
int X[] = {1, -1, 0, 0};
int Y[] = {0, 0, 1, -1};
const int inf = 1000;

int getWeight(int x, int y) {
   	return cost[x][y] - '0'; 
}
bool isValid(int x, int y) {
   	return x >= 0 && x < N && y >= 0 && y < M;
}

int bfs(int r, int c) {
	memset(dist, 1, sizeof(dist));
	deque <pair <int, int> > dq;
	dist[r][c] = getWeight(r, c);
	dq.push_back(make_pair(r, c));
	int ret = dist[r][c];

	while(!dq.empty()) {
		pair <int, int> nd = dq.front();
		int d = dist[nd.first][nd.second]; 
		dq.pop_front();

		for(int i = 0; i < 4; ++i) {
			int x = nd.first + X[i];
			int y = nd.second + Y[i]; 

			if(!isValid(x, y) || dist[x][y] < inf)
				continue;

			int w = getWeight(x, y);
			dist[x][y] = d + w;
			ret = max(ret, dist[x][y]);
			if(w == 0)
				dq.push_front(make_pair(x, y));
			else
				dq.push_back(make_pair(x, y));
		}
	}
	return ret;
}

int GameOnABoard::optimalChoice (vector <string> _cost) 
{
	cost = _cost;
	N = cost.size();
	M = cost[0].size();

/*
	for(auto it = begin(cost); it != end(cost); ++it) {
		 cout << *it << "\n";
	}
	cout << "\n";
*/
	int ret = inf;
	for(int i = 0; i < N; ++i) {
		for(int j = 0; j < M; ++j) {
			ret = min(bfs(i, j), ret);
		}
	}

	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	GameOnABoard *obj;
	int answer;
	obj = new GameOnABoard();
	clock_t startTime = clock();
	answer = obj->optimalChoice(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"11","10"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"01","10"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"111001","001000","111111","001111","001100","001011","111001","010011"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"001001101011","110011001101","111111000001","111101010001","011100101111","110010111000","111111110101","111011110111","111100100011","000000000110","101011011110","011111000111","101111001011"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"110010100101010110100010001100111011","001000000110100011010100000001001000","011000110111101001011101110111000100","111001011000100101111010100110110011","111000011101001010000100001010000010","111001110010100101000001001100011011","111110100111010101100000100111000111","011111111100100111111110000001110111","110000010101001111100011110000001000","010010110111111100011101100000011010","110001100001111001101000101110110001","110010000111011110000010110111010101","100100110101001001101000001101101101","001011101101001100111110101111001110","111010111111111100110100000011111100","110101101000001001000100101011100000","011011001011010001001000100000110101","011111111100000011010111010011010100","111001111110001110001110010100111010","000001111000001100101010000001101110","010000110000010010111110111000010101","100010010100110011000111101001101011","111010110001101011010001111101111100","000111110000110000000101100101000110","110000010111001001110001101010111100","0111111011010010110110100"
			"11111100010","110101111101010100110010000011001101","101101111001010100101111100001110001","000110010100101111011011110010010010","110101010011101000111011100000010011","110001010001110011010100110000010001","111010101100111100100011001101010100","011000000000100001011010000100010001","100000110110000001010001001111010000","100011111110010011011011001110011111","101100001111100101001101100000100001","010000111011010110011001110011111000","100010100111110111001010100101111010","000110011110111011111000101000001000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 7;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// This problem statement contains superscripts and/or subscripts. These may not display properly outside the applet.
// 
// Alice and Bob are playing a game on a rectangular board. We use (i, j) to denote the j-th cell in the i-th row (0-based index). Each cell has a cost of either 0 or 1 and they are given by the vector <string> cost. The j-th character of i-th element in cost (0-based index) denotes the cost of cell (i, j). A path between two distinct cells (x1, y1) and (x2, y2) is a sequence of cells (c0, c1, ..., ck) such that c0=(x1, y1), ck=(x2, y2) and for each i from 0 to k-1, cells ci and ci+1 have a common side. Cost of a path is the total cost of cells on this path.
// 
// The game is played as follows: First Alice chooses a cell (x1,y1), then Bob chooses a cell (x2,y2) which is different from (x1, y1). Finally, they compute the value L: the minimum cost of a path between (x1,y1) and (x2,y2). Alice's goal is to minimize L, and Bob's goal is to maximize L. Compute and return the value L that will be achieved if both players play optimally.
// 
// DEFINITION
// Class:GameOnABoard
// Method:optimalChoice
// Parameters:vector <string>
// Returns:int
// Method signature:int optimalChoice(vector <string> cost)
// 
// 
// NOTES
// -Two cells (x1, y1) and (x2, y2) have a common side if |x1-x2|+|y1-y2|=1.
// 
// 
// CONSTRAINTS
// -cost will contain between 2 and 40 elements, inclusive.
// -Each element of cost will be between 2 and 40 characters long, inclusive.
// -Each element of cost will be of the same length.
// -Each element of cost will consist of '0's and '1's only.
// 
// 
// EXAMPLES
// 
// 0)
// {"11",
//  "10"}
// 
// Returns: 2
// 
// Regardless of Alice's choice, Bob can always achieve L=2 by choosing the opposite corner.
// Sometimes he also has other optimal moves. For example, if Alice chooses (0,0), Bob can choose any of the other three cells to get L=2.
// 
// 1)
// {"01",
//  "10"}
// 
// Returns: 1
// 
// Alice will not choose the cell (0,1), nor the cell (1,0). If she chooses one of those, Bob will choose the other one and L will be 2.
// Alice prefers the other option. If she chooses one of the cells (0,0) or (1,1), Bob can only achieve L=1.
// 
// 2)
// {"111001",
//  "001000",
//  "111111",
//  "001111",
//  "001100",
//  "001011",
//  "111001",
//  "010011"}
// 
// Returns: 3
// 
// 
// 
// 3)
// {"001001101011",
//  "110011001101",
//  "111111000001",
//  "111101010001",
//  "011100101111",
//  "110010111000",
//  "111111110101",
//  "111011110111",
//  "111100100011",
//  "000000000110",
//  "101011011110",
//  "011111000111",
//  "101111001011"}
// 
// Returns: 5
// 
// 
// 
// 4)
// {"110010100101010110100010001100111011",
//  "001000000110100011010100000001001000",
//  "011000110111101001011101110111000100",
//  "111001011000100101111010100110110011",
//  "111000011101001010000100001010000010",
//  "111001110010100101000001001100011011",
//  "111110100111010101100000100111000111",
//  "011111111100100111111110000001110111",
//  "110000010101001111100011110000001000",
//  "010010110111111100011101100000011010",
//  "110001100001111001101000101110110001",
//  "110010000111011110000010110111010101",
//  "100100110101001001101000001101101101",
//  "001011101101001100111110101111001110",
//  "111010111111111100110100000011111100",
//  "110101101000001001000100101011100000",
//  "011011001011010001001000100000110101",
//  "011111111100000011010111010011010100",
//  "111001111110001110001110010100111010",
//  "000001111000001100101010000001101110",
//  "010000110000010010111110111000010101",
//  "100010010100110011000111101001101011",
//  "111010110001101011010001111101111100",
//  "000111110000110000000101100101000110",
//  "110000010111001001110001101010111100",
//  "011111101101001011011010011111100010",
//  "110101111101010100110010000011001101",
//  "101101111001010100101111100001110001",
//  "000110010100101111011011110010010010",
//  "110101010011101000111011100000010011",
//  "110001010001110011010100110000010001",
//  "111010101100111100100011001101010100",
//  "011000000000100001011010000100010001",
//  "100000110110000001010001001111010000",
//  "100011111110010011011011001110011111",
//  "101100001111100101001101100000100001",
//  "010000111011010110011001110011111000",
//  "100010100111110111001010100101111010",
//  "000110011110111011111000101000001000"}
// 
// Returns: 7
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <bits/stdc++.h>
using namespace std;

class GearsDiv1
{
public:
	int getmin(string color, vector <string> graph);
};

int rt[100], N;
bool vis[100];
vector <string> graph;
string color;

bool dfs(int u, char ri) {
	if(u == -1)
		return true;
	if(vis[u])
		return false;
	vis[u] = true;
	for(int i = 0; i < N; ++i) if(color[i]==ri && graph[u][i]=='Y' && dfs(rt[i], ri)) {
		rt[i] = u;
		return true;
	}
	return false;
}

int solve(char le, char ri) {
	int ret = 0;
	memset(rt, -1, sizeof(rt));
	for(int i = 0; i < N; ++i) if(color[i] == le){
		memset(vis, 0, sizeof(vis));
		if(dfs(i, ri))
			ret++;
	}
	return ret;
}

int GearsDiv1::getmin (string _color, vector <string> _graph) 
{
	graph=_graph;
	color=_color;
	N = color.size();
	int ret=N;

	ret = min(ret, solve('R', 'G'));
	ret = min(ret, solve('R', 'B'));
	ret = min(ret, solve('G', 'B'));

	return ret;
}



// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, vector <string> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	GearsDiv1 *obj;
	int answer;
	obj = new GearsDiv1();
	clock_t startTime = clock();
	answer = obj->getmin(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <string> p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = "RGB";
	string t1[] = {"NYY","YNY","YYN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "RGBR";
	string t1[] = {"NNNN","NNNN","NNNN","NNNN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "RGBR";
	string t1[] = {"NYNN","YNYN","NYNY","NNYN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "RRRRRGRRBGRRGBBGGGBRRRGBRGRRGG";
	string t1[] = {"NNNNNYNNNYNNYNNNYNNNNNNNNYNNYY","NNNNNNNNYNNNYNYNNYNNNNYNNYNNYY","NNNNNYNNNNNNNNNNNNYNNNNNNYNNNY","NNNNNNNNNYNNYNNYYYNNNNYNNYNNNN","NNNNNNNNNYNNYNNYYYNNNNYNNNNNNN","YNYNNNYYYNNYNYYNNNNNYYNYNNYYNN","NNNNNYNNNNNNNNNYYYNNNNYNNYNNYY","NNNNNYNNNNNNNNNYNNNNNNNNNNNNYN","NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY","YNNYYNNNYNNNNYYNNNYNYYNYNNNNNN","NNNNNNNNNNNNYNNYNYNNNNYNNNNNNY","NNNNNYNNNNNNYNNYYYNNNNNNNNNNYN","YYNYYNNNYNYYNYYNNNYNYNNYNNNNNN","NNNNNYNNNYNNYNNYYYNNNNYNNYNYYY","NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY","NNNYYNYYYNYYNYYNNNYNYNNYYNYYNN","YNNYYNYNYNNYNYYNNNYNNNNYYNNYNN","NYNYYNYNYNYYNYYNNNNYYNNYYNYNNN","NNYNNNNNNYNNYNNYYNNNNNYNNYNNNY","NNNNNNNNNNNNNNNNNYNNNNYNNYNNNY","NNNNNYNNNYNNYNNYNYNNNNYNNNNNYY","NNNNNYNNNYNNNNNNNNNNNNYNNNNNNN","NYNYYNYNYNYNNYYNNNYYYYNYYNYNNN","NNNNNYNNNYNNYNNYYYNNNNYNNNNNNY","NNNNNNNNNNNNNNNYYYNNNNYNNYNNYY","YYYYNNYNYNNNNYYNNNYYNNNNYNYYNN","NNNNNYNNNNNNNNNYNYNNNNYNNYNNYN","NNNNNYNNNNNNNYNYYNNNNNNNNYNNYY","YYNNNNYYYNNYNYYNNNNNYNNNYNYYNN","YYYNNNYNYNYNNYYNNNYYYNNYYNNYNN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "RRRGGG";
	string t1[] = {"NNNYNN","NNNYNN","NNNNYY","YYNNNN","NNYNNN","NNYNNN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Goose Tattarrattat has a machine that contains N gears (cogwheels).
// The gears are numbered 0 through N-1.
// Each of the gears has one of three colors: red, green, or blue.
// 
// Some pairs of gears mesh.
// Let X and Y be two meshing gears.
// Note that if X is turning, Y must clearly be turning in the opposite direction (clockwise vs. counter-clockwise).
// Two gears with the same color never mesh.
// Apart from that, do not assume anything about the pairs of meshing gears.
// 
// You are given a string color and a vector <string> graph.
// For each i, character i of color represents the color of gear i: 'R' is red, 'G' is green, and 'B' is blue.
// The vector <string> graph contains the information on meshing pairs of gears:
// If the j-th character of the i-th element of graph is 'Y', gear i meshes with gear j.
// 
// We want all gears to turn at the same time.
// Additionally, all gears of the same color must turn in the same direction.
// Return the minimal number of gears that have to be removed from the machine in order to achieve this goal.
// 
// DEFINITION
// Class:GearsDiv1
// Method:getmin
// Parameters:string, vector <string>
// Returns:int
// Method signature:int getmin(string color, vector <string> graph)
// 
// 
// NOTES
// -Removing a gear creates a gap between the other gears, no new meshing pairs of gears are created by removing a gear.
// -The graph described by graph is not necessarily planar.
// 
// 
// CONSTRAINTS
// -color will contain between 2 and 50 characters, inclusive.
// -Each character in color will be 'R' or 'G' or 'B'.
// -graph will contain exactly N elements, where N is the number of characters in color.
// -Each element of graph will contain exactly N characters, where N is the number of characters in color.
// -Each character in graph will be either 'Y' or 'N'.
// -For each i, the i-th character of the i-th element of graph will be 'N'.
// -For each i and j, the i-th character of the j-th element of graph and the j-th character of the i-th element of graph will be same.
// -For each i and j, if the i-th and the j-th character of color are equal, then the i-th character of the j-th element of graph will be 'N'.
// 
// 
// EXAMPLES
// 
// 0)
// "RGB"
// {"NYY","YNY","YYN"}
// 
// Returns: 1
// 
// We have three gears, each meshes with each of the others.
// In this configuration the gears are not able to turn at all.
// However, as soon as we remove any of the gears, the other two will be able to turn.
// 
// 1)
// "RGBR"
// {"NNNN","NNNN","NNNN","NNNN"}
// 
// Returns: 0
// 
// Here, each of the gears can turn without interacting with the others.
// 
// 2)
// "RGBR"
// {"NYNN","YNYN","NYNY","NNYN"}
// 
// Returns: 1
// 
// These are four gears arranged into a row. It is possible to turn all these gears at the same time, but the two red gears would turn in opposite directions. Thus we need to remove at least one gear.
// 
// 3)
// "RRRRRGRRBGRRGBBGGGBRRRGBRGRRGG"
// {"NNNNNYNNNYNNYNNNYNNNNNNNNYNNYY",
//  "NNNNNNNNYNNNYNYNNYNNNNYNNYNNYY",
//  "NNNNNYNNNNNNNNNNNNYNNNNNNYNNNY",
//  "NNNNNNNNNYNNYNNYYYNNNNYNNYNNNN",
//  "NNNNNNNNNYNNYNNYYYNNNNYNNNNNNN",
//  "YNYNNNYYYNNYNYYNNNNNYYNYNNYYNN",
//  "NNNNNYNNNNNNNNNYYYNNNNYNNYNNYY",
//  "NNNNNYNNNNNNNNNYNNNNNNNNNNNNYN",
//  "NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY",
//  "YNNYYNNNYNNNNYYNNNYNYYNYNNNNNN",
//  "NNNNNNNNNNNNYNNYNYNNNNYNNNNNNY",
//  "NNNNNYNNNNNNYNNYYYNNNNNNNNNNYN",
//  "YYNYYNNNYNYYNYYNNNYNYNNYNNNNNN",
//  "NNNNNYNNNYNNYNNYYYNNNNYNNYNYYY",
//  "NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY",
//  "NNNYYNYYYNYYNYYNNNYNYNNYYNYYNN",
//  "YNNYYNYNYNNYNYYNNNYNNNNYYNNYNN",
//  "NYNYYNYNYNYYNYYNNNNYYNNYYNYNNN",
//  "NNYNNNNNNYNNYNNYYNNNNNYNNYNNNY",
//  "NNNNNNNNNNNNNNNNNYNNNNYNNYNNNY",
//  "NNNNNYNNNYNNYNNYNYNNNNYNNNNNYY",
//  "NNNNNYNNNYNNNNNNNNNNNNYNNNNNNN",
//  "NYNYYNYNYNYNNYYNNNYYYYNYYNYNNN",
//  "NNNNNYNNNYNNYNNYYYNNNNYNNNNNNY",
//  "NNNNNNNNNNNNNNNYYYNNNNYNNYNNYY",
//  "YYYYNNYNYNNNNYYNNNYYNNNNYNYYNN",
//  "NNNNNYNNNNNNNNNYNYNNNNYNNYNNYN",
//  "NNNNNYNNNNNNNYNYYNNNNNNNNYNNYY",
//  "YYNNNNYYYNNYNYYNNNNNYNNNYNYYNN",
//  "YYYNNNYNYNYNNYYNNNYYYNNYYNNYNN"}
// 
// Returns: 3
// 
// 
// 
// END KAWIGIEDIT TESTING//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
//With unused code cleaner (beta) by ahmed_aly

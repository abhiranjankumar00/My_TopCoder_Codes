#include <bits/stdc++.h>
using namespace std;

class IsHomomorphism
{
public:
	vector <string> numBad(vector <string> source, vector <string> target, vector <int> mapping);
};

vector <string> IsHomomorphism::numBad (vector <string> source, vector <string> target, vector <int> mapping) 
{
	vector <string> ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, vector <int> p2, bool hasAnswer, vector <string> p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	IsHomomorphism *obj;
	vector <string> answer;
	obj = new IsHomomorphism();
	clock_t startTime = clock();
	answer = obj->numBad(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p3.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p3[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p3.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p3[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	vector <string> p1;
	vector <int> p2;
	vector <string> p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"0000","0123","0202","0321"};
	p1 = {"0000","0123","0202","0321"};
	p2 = {0,1,2,3};
	p3 = {};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"0123456","1234560","2345601","3456012","4560123","5601234","6012345"};
	p1 = {"0123456","1234560","2345601","3456012","4560123","5601234","6012345"};
	p2 = {1,3,2,1,2,1,1};
	p3 = {"(0,0)","(0,1)","(0,2)","(0,3)","(0,4)","(0,5)","(0,6)","(1,0)","(1,1)","(1,2)","(1,3)","(1,4)","(1,5)","(1,6)","(2,0)","(2,1)","(2,2)","(2,3)","(2,4)","(2,5)","(3,0)","(3,1)","(3,2)","(3,3)","(3,4)","(3,5)","(4,0)","(4,1)","(4,2)","(4,3)","(4,4)","(4,5)","(4,6)","(5,0)","(5,1)","(5,2)","(5,3)","(5,4)","(5,5)","(6,0)","(6,1)","(6,4)","(6,6)"};
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"012","120","210"};
	p1 = {"012","120","110"};
	p2 = {0,1,2};
	p3 = {"(2,0)"};
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"012","120","210"};
	p1 = {"012","120","210"};
	p2 = {1,2,0};
	p3 = {"(0,0)","(0,1)","(0,2)","(1,0)","(1,2)","(2,0)","(2,2)"};
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"01","10"};
	p1 = {"10","01"};
	p2 = {1,0};
	p3 = {};
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// An operation table tells you which value is produced when a particular operation is applied to two operands.  For example, 
//   0123
//  +----
// 0|0000                            0000
// 1|0123    or more succinctly      0123
// 2|0202                            0202
// 3|0321                            0321
// is a table for standard integer multiplication mod 4.  In the table on the left, the first row and column refer to the operands.  This information is implicit in the more succinct form.  Looking at the table we can see that 2 is produced when the operation is applied to 2 and 3.  More precisely, if the table above defines the operation @, then a@b is the value in row a column b of the table.  
// 
// Using a table you could describe any operation by putting the correct values in the table.  In this problem you will be given 
// two vector <string>s source and target which are tables describing two operations.  The tables will be in 
// the succinct form shown above, where the first row and column are assumed to correspond to 0, and so forth.  For added 
// convenience, all results will be single digits, the tables will always be square, and will never have more than 10 rows.
// 
// In addition, you will be given a vector <int> mapping which will contain the same number of elements as 
// source and target.  mapping defines a function that maps the value i to mapping[i]. 
// For example, if mapping = {2,2,1,3} then 0 and 1 map to 2, 2 maps to 1, and 3 maps to 3.
// 
// A homomorphism, for the purposes of this problem, will be a mapping that preserves the following equality:
// 
// mapping(a@b) = mapping(a)~mapping(b) for all a,b
//  
// For all a,b means a and b can assume all values between 0 and len-1 inclusive, where len is the number of elements in source.  @ denotes the operation 
// defined by source, and ~ denotes the operation defined by target.
// 
// Your method will return a vector <string> containing all pairs (a,b) for which the above equality fails to hold 
// true for the given mapping.  The pair (a,b) should be denoted as (quotes for clarity) "(a,b)" where a,b have no extra leading zeros.  Note that 
// the string contains no spaces.  The returned vector <string> should be sorted in ascending order by 
// a value, with ties broken using ascending b values.  There should be no repeats.
// 
// DEFINITION
// Class:IsHomomorphism
// Method:numBad
// Parameters:vector <string>, vector <string>, vector <int>
// Returns:vector <string>
// Method signature:vector <string> numBad(vector <string> source, vector <string> target, vector <int> mapping)
// 
// 
// CONSTRAINTS
// -source will contain between 2 and 10 elements inclusive
// -target will contain the same number of elements as source
// -mapping will contain the same number of elements as source
// -Each element of mapping must be between 0 and len-1 inclusive, where len is the number of elements in source
// -Each element of source must contain exactly len characters, where len is the number of elements in source
// -Each element of target must contain exactly len characters, where len is the number of elements in source
// -Each character in source and target will be in the first len characters of (quotes for clarity) "0123456789", where len is the number of elements in source
// 
// 
// EXAMPLES
// 
// 0)
// {"0000",
//  "0123",
//  "0202",
//  "0321"}
// {"0000",
//  "0123",
//  "0202",
//  "0321"}
// {0,1,2,3}
// 
// Returns: { }
// 
// source and target are identical, and mapping takes every element to itself.  Clearly all pairs will satisfy the equality.
// 
// 1)
// {"0123456",
//  "1234560",
//  "2345601",
//  "3456012",
//  "4560123",
//  "5601234",
//  "6012345"}
// {"0123456",
//  "1234560",
//  "2345601",
//  "3456012",
//  "4560123",
//  "5601234",
//  "6012345"}
// {1,3,2,1,2,1,1}
// 
// Returns: { "(0,0)",  "(0,1)",  "(0,2)",  "(0,3)",  "(0,4)",  "(0,5)",  "(0,6)",  "(1,0)",  "(1,1)",  "(1,2)",  "(1,3)",  "(1,4)",  "(1,5)",  "(1,6)",  "(2,0)",  "(2,1)",  "(2,2)",  "(2,3)",  "(2,4)",  "(2,5)",  "(3,0)",  "(3,1)",  "(3,2)",  "(3,3)",  "(3,4)",  "(3,5)",  "(4,0)",  "(4,1)",  "(4,2)",  "(4,3)",  "(4,4)",  "(4,5)",  "(4,6)",  "(5,0)",  "(5,1)",  "(5,2)",  "(5,3)",  "(5,4)",  "(5,5)",  "(6,0)",  "(6,1)",  "(6,4)",  "(6,6)" }
// 
// 2)
// {"012",
//  "120",
//  "210"}
// {"012",
//  "120",
//  "110"}
// {0,1,2}
// 
// Returns: { "(2,0)" }
// 
// The pair (2,0) is the only one that breaks the equality.  To verify this breakage:
// mapping of 2@0 = mapping of 2 = 2
// (mapping of 2)~(mapping of 0) = (2)~(0)=1
// 
// 3)
// {"012",
//  "120",
//  "210"}
// {"012",
//  "120",
//  "210"}
// {1,2,0}
// 
// Returns: { "(0,0)",  "(0,1)",  "(0,2)",  "(1,0)",  "(1,2)",  "(2,0)",  "(2,2)" }
// 
// 4)
// {"01","10"}
// {"10","01"}
// {1,0}
// 
// Returns: { }
// 
// END KAWIGIEDIT TESTING

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef string ST;
typedef stringstream SS;

#define pb	push_back
#define mp	make_pair
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0; i < n; i++)
#define forab(i, a, b)	for(int i = a; i <= b; i++)
#define rep(i, a, b)	for(int i = a; i>=b; i--)

class JarBox
{
public:
	int numJars(int radius, int woodlength)
	{
		int ret = 10;
		ret <?= 100;
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	JarBox *obj;
	int answer;
	obj = new JarBox();
	clock_t startTime = clock();
	answer = obj->numJars(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 1;
	p1 = 8;
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 1;
	p1 = 16;
	p2 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 1;
	p1 = 18;
	p2 = 4;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 1;
	p1 = 45;
	p2 = 32;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 6;
	p1 = 1269;
	p2 = 784;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Note to plugin users:  There are images in the problem statement and examples.  Please use the applet to view them.
// 
// 
// 
// You have a piece of wood that you want to use to make the walls of a box that holds jars (shaped as perfect cylinders).  The piece of wood is one jar height wide, and the resulting box will only hold one layer of jars.  The jars will be placed upright in the box.  In order to make the walls of the box, you need to cut the wood into four separate pieces.  Each piece needs to be cut such that the four pieces attached at the ends form a rectangle.
// 
// 
// 
// To minimize the stress on each jar, you want to pack the jars into the box as tightly as possible, so they are touching as many other jars as possible.  The jars in a single row must be horizontally adjacent to each other.  However, each successive row must be skewed one radius such that the jars sit exactly between two jars from the previous row to form a hexagonal pattern (Note that this may not be the most efficient space-wise).  Here is an example (as viewed from above):
// 
// 
// 
// Given the radius, in inches, of the jars that you would like to store, and the woodlength in inches, return the maximum number of jars you can store in a box whose perimeter is at most woodlength inches.
// 
// 
// DEFINITION
// Class:JarBox
// Method:numJars
// Parameters:int, int
// Returns:int
// Method signature:int numJars(int radius, int woodlength)
// 
// 
// NOTES
// -The box dimensions do not have to be integers
// -Even if it is possible to fit more jars in by placing jars so that adjacent rows are not skewed, this is not a legal arrangement of the jars.
// 
// 
// CONSTRAINTS
// -radius will be between 1 and 10, inclusive.
// -woodlength will be between 8 and 10000, inclusive.
// -For all possible boxes that contain more than one row of jars, the optimal length of wood required will be at least .000001 inches smaller than the woodlength given.
// -It will be possible to store at least one jar using the woodlength given.
// 
// 
// EXAMPLES
// 
// 0)
// 1
// 8
// 
// Returns: 1
// 
// The smallest box for the given radius.  Only one jar barely fits into the box.
// 
// 1)
// 1
// 16
// 
// Returns: 3
// 
// 
// There are two ways to get 3 jars in this box.  First, you could have one row of 3 jars.  Another way is to have two rows, one row of 2 jars, and one row of 1 jar like so:
// 
// 
// 
// 
// 
// 
// 
// Note that although it would be more efficient to store the jars in a square pattern, this is not allowed.
// 
// 
// 2)
// 1
// 18
// 
// Returns: 4
// 
// 
// In order to fit 4 jars in this box, the width must be 5, and the rows both contain 2 jars each.  The following diagram shows how the jars will sit:
// 
// 
// 
// 
// 
// 
// 3)
// 1
// 45
// 
// Returns: 32
// 
// If we make the box 10 inches wide, it will fit exactly 5 jars across on the odd rows (starting with the bottom), and 4 jars across on all the even rows.  This will allow us to create 4 rows of 5 jars across, and 3 rows of 4 jars across.  The optimal dimensions of the box will be about 10 x 12.392305.
// 
// 4)
// 6
// 1269
// 
// Returns: 784
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

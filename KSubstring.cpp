#include <bits/stdc++.h>
using namespace std;

class KSubstring
{
public:
	vector <int> maxSubstring(int A0, int X, int Y, int M, int n);
};

vector <int> KSubstring::maxSubstring (int A0, int X, int Y, int M, int n) 
{
	vector <int> ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, int p4, bool hasAnswer, vector <int> p5) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4;
	cout << "]" << endl;
	KSubstring *obj;
	vector <int> answer;
	obj = new KSubstring();
	clock_t startTime = clock();
	answer = obj->maxSubstring(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p5.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p5[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p5.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p5[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	vector <int> p5;
	
	{
	// ----- test 0 -----
	p0 = 5;
	p1 = 3;
	p2 = 4;
	p3 = 25;
	p4 = 5;
	int t5[] = {2,1};
			p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 8;
	p1 = 19;
	p2 = 17;
	p3 = 2093;
	p4 = 12;
	int t5[] = {5,161};
			p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 53;
	p1 = 13;
	p2 = 9;
	p3 = 65535;
	p4 = 500;
	int t5[] = {244,0};
			p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 12;
	p1 = 34;
	p2 = 55;
	p3 = 7890;
	p4 = 123;
	int t5[] = {35,4};
			p5.assign(t5, t5 + sizeof(t5) / sizeof(t5[0]));
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// 	You are given numbers A0, X, Y, M and n. 
// 	Generate a list A of length n using the following recursive definition:
// 	A[0] = A0
// 	A[i] = (A[i - 1] * X + Y) MOD M (note that A[i - 1] * X + Y may overflow 32-bit integer)
// 
// 
// 
// 	Let s(i, k) be a sum of k consecutive elements of the list A starting with the element at
// 	position i (0 indexed).
// 	More formally, s(i, k) = A[i] + A[i + 1] + ... + A[i + k - 1].
// 	
// 	Your task is to find the smallest difference between s(i, k) and s(j, k) 
// 	(where difference is defined as abs(s(i, k) - s(j, k))) such that
// 	i + k <= j. 
// 	In other words, you must find the smallest difference between two subsequences of the same 
// 	length that do not overlap.
// 	Call this smallest difference val, and return a vector <int> containing exactly two elements.
// 	The first element should be k, and the second element should be val.
// 	If there are multiple solutions with the same val, return the one among them with the highest k.
// 
// 
// 
// DEFINITION
// Class:KSubstring
// Method:maxSubstring
// Parameters:int, int, int, int, int
// Returns:vector <int>
// Method signature:vector <int> maxSubstring(int A0, int X, int Y, int M, int n)
// 
// 
// CONSTRAINTS
// -M will be between 1 and 1,000,000,000, inclusive.
// -A0 will be between 0 and M-1, inclusive.
// -X will be between 0 and M-1, inclusive.
// -Y will be between 0 and M-1, inclusive.
// -n will be between 2 and 3,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 5
// 3
// 4
// 25
// 5
// 
// Returns: {2, 1 }
// 
// The elements of the list are {5, 19, 11, 12, 15}. There is no way to find two subsequences that have equal sums and do not overlap, so there is no way to obtain 0 as a difference. |s(0, 2) - s(2, 2)| = 1 and that is the minimal difference. Note that |s(2, 1) - s(3, 1)| is also 1, but we don't choose these subsequences because they have a lower value for k.
// 
// 1)
// 8
// 19
// 17
// 2093
// 12
// 
// Returns: {5, 161 }
// 
// The elements of the list are {8, 169, 1135, 652, 1940, 1296, 1618, 1457, 491, 974, 1779, 330}. The smallest difference is |s(1, 5) - s(7, 5)| = 161.
// 
// 2)
// 53
// 13
// 9
// 65535
// 500
// 
// Returns: {244, 0 }
// 
// 
// 
// 3)
// 12
// 34
// 55
// 7890
// 123
// 
// Returns: {35, 4 }
// 
// 
// 
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

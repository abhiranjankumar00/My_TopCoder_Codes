#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)


/*
map <ST, int> m;

int num2(ST st) {
	if(present(st, m))
		return m[st];
	if(st[1] == 'I' || st[1] == 'V') {
		int ans = 10;
		ans += m[st.substr(1)];
		return ans;
	}
	if(st.size() >= 3 && st.substr(0, 3) == "XXX") {
		int ans = m[st.substr(0, 3)];
		ans += m[st.substr(3)];
		return ans;
	}
	int ans = m[st.substr(0, 2)];
	ans += m[st.substr(2)];
	return ans;
}

const bool lessNew(const ST & _st1, const ST & _st2) {
	ST st1 = _st1, st2 = _st2;
	SS ss1(st1), ss2(st2);
	ST tmp1, tmp2;
	ST n1, n2;
	ss1 >> tmp1 >> n1;
	ss2 >> tmp2 >> n2;
	if(tmp1 != tmp2)
		return tmp1 < tmp2;
	return num2(n1) < num2(n2);
}
*/

ST ones[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
ST tens[] = {"", "X", "XX", "XXX", "XL", "L"};
map <ST, int> m;
bool lessNew(ST a, ST b) {
	SS as(a), bs(b);
	ST aname, bname, anum, bnum;
	as >> aname >> anum;
	bs >> bname >> bnum;

//	cout << "aName : " << aname << " \t anum : " << anum << " \t num = " << m[anum] << endl;
//	cout << "bName : " << bname << " \t bnum : " << bnum << " \t num = " << m[bnum] << endl;
//	Pf("%15s : %6s : %2d\n", aname.c_str(), anum.c_str(), m[anum]);
//	Pf("%15s : %6s : %2d\n", bname.c_str(), bnum.c_str(), m[bnum]);

	if(aname != bname)
		return aname < bname;
	int an = 0, bn = 0;
	return m[anum] < m[bnum];
}

class KingSort
{

public:
	vector <string> getSortedList(vector <string> kings) {
		m.clear();
		forab(i, 0, 5) {
			forab(j, 0, 9)
				m[tens[i] + ones[j]] = i*10 + j;
		}

//		tr(it, m) 
//			cout << it->first << ":" << it->second << "\t";
		sort(all(kings), lessNew);
		return kings;
	}
/*
	vector <string> getSortedList(vector <string> kings)
	{
		m.clear();
m["I"] = 1;m["II"] = 2;m["III"] = 3;m["IV"] = 4;m["V"] =5 ;m["VI"] = 6;
m["VII"] = 7;m["VIII"] = 8;m["IX"] = 9;m["X"] = 10;
m["XX"] = 20;m["XXX"] = 30;m["XL"] = 40;m["L"] = 50;
m["XI"] = 11; m["XV"] = 15;
		sort(all(kings), lessNew);
		return kings;
		
	}
*/
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	KingSort *obj;
	vector <string> answer;
	obj = new KingSort();
	clock_t startTime = clock();
	answer = obj->getSortedList(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"Louis IX","Louis VIII"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Louis VIII","Louis IX"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"Louis IX","Philippe II"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Louis IX","Philippe II"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"Richard III","Richard I","Richard II"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Richard I","Richard II","Richard III"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"John X","John I","John L","John V"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"John I","John V","John X","John L"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"Philippe VI","Jean II","Charles V","Charles VI","Charles VII","Louis XI"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Charles V","Charles VI","Charles VII","Jean II","Louis XI","Philippe VI"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"Philippe II","Philip II"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Philip II","Philippe II"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	string t0[] = {"Henri XXI","Ivan XXI","Zemco XLII","Charles XXXI","Ivan L","Zemco XL","Zemco L","Charles V","Zemco XXV","Henri XXVI","Henri VI","Charles XXXVI","Henri XXX","Ivan XXIX","Ivan XXXIX","Ivan XLV","Charles XXXIX","Ivan XXXVIII","Charles XVII","Henri XXXVIII","Zemco XI","Henri VIII","Ivan XL","Zemco XLVII","Henri XXIV","Henri L","Charles XV","Ivan II","Charles XVIII","Charles X","Zemco XXXVIII","Henri XXIII","Henri XLII","Zemco XX","Charles XX","Charles XVI","Ivan XXXVI","Ivan VII","Charles XLVI","Charles XLV","Zemco XIII","Ivan XXXIV","Zemco VI","Ivan XXVII","Henri XXXIV","Ivan XIV","Charles XXXVIII","Zemco XXVII"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"Charles V","Charles X","Charles XV","Charles XVI","Charles XVII","Charles XVIII","Charles XX","Charles XXXI","Charles XXXVI","Charles XXXVIII","Charles XXXIX","Charles XLV","Charles XLVI","Henri VI","Henri VIII","Henri XXI","Henri XXIII","Henri XXIV","Henri XXVI","Henri XXX","Henri XXXIV","Henri XXXVIII","Henri XLII","Henri L","Ivan II","Ivan VII","Ivan XIV","Ivan XXI","Ivan XXVII","Ivan XXIX","Ivan XXXIV","Ivan XXXVI","Ivan XXXVIII","Ivan XXXIX","Ivan XL","Ivan XLV","Ivan L","Zemco VI","Zemco XI","Zemco XIII","Zemco XX","Zemco XXV","Zemco XXVII","Zemco XXXVIII","Zemco XL","Zemco XLII","Zemco XLVII","Zemco L"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Every good encyclopedia has an index. The entries in the index are usually sorted in alphabetic order. However, there are some notable exceptions. In this task we will consider one such exception: the names of kings.
// 
// 
// 
// In many countries it was common that kings of the same name received ordinal numbers. This ordinal number was written as a Roman numeral and appended to the actual name of the king.
// For example, "Louis XIII" (read: Louis the thirteenth) was the thirteenth king of France having the actual name Louis.
// 
// 
// 
// In the index of an encyclopedia, kings who share the same name have to be sorted according to their ordinal numbers. For example, Louis the 9th should be listed after Louis the 8th.
// 
// 
// 
// You are given a vector <string> kings. Each element of kings is the name of one king. The name of each king consists of his actual name, a single space, and a Roman numeral. Return a vector <string> containing the names
// rearranged into their proper order: that is, the kings have to be in ascending lexicographic order according to their actual name, and kings with the same name have to be in the correct numerical order.
// 
// 
// DEFINITION
// Class:KingSort
// Method:getSortedList
// Parameters:vector <string>
// Returns:vector <string>
// Method signature:vector <string> getSortedList(vector <string> kings)
// 
// 
// NOTES
// -The Roman numerals for 1 through 10 are I, II, III, IV, V, VI, VII, VIII, IX, and X.
// -The Roman numerals for 20, 30, 40, and 50 are XX, XXX, XL, and L.
// -The Roman numeral for any other two-digit number less than 50 can be constructed by concatenating the numeral for its tens and the numeral for its ones. For example, 47 is 40 + 7 = "XL" + "VII" = "XLVII".
// -Standard string comparison routines give the correct ordering for the actual names of kings.
// -Formally, given two different strings A and B we say that A is lexicographically smaller than B if either (A is a prefix of B) or (there is at least one index where A and B differ, and for the smallest such index the character in A has a lower ASCII value than the character in B).
// 
// 
// CONSTRAINTS
// -Each actual name of a king will be a string containing between 1 and 20 characters, inclusive.
// -Each actual name will start by an uppercase letter ('A'-'Z').
// -Each other character in each actual name will be a lowercase letter ('a'-'z').
// -kings will contain between 1 and 50 elements, inclusive.
// -Each element of kings will have the form "ACTUALNAME ORDINAL", where ACTUALNAME is an actual name as defined above, and ORDINAL is a valid Roman numeral representing a number between 1 and 50, inclusive.
// -The elements of kings will be pairwise distinct.
// 
// 
// EXAMPLES
// 
// 0)
// {"Louis IX", "Louis VIII"}
// 
// Returns: {"Louis VIII", "Louis IX" }
// 
// Louis the 9th should be listed after Louis the 8th.
// 
// 1)
// {"Louis IX", "Philippe II"}
// 
// Returns: {"Louis IX", "Philippe II" }
// 
// Actual names take precedence over ordinal numbers.
// 
// 2)
// {"Richard III", "Richard I", "Richard II"}
// 
// Returns: {"Richard I", "Richard II", "Richard III" }
// 
// 
// 
// 3)
// {"John X", "John I", "John L", "John V"}
// 
// Returns: {"John I", "John V", "John X", "John L" }
// 
// 
// 
// 4)
// {"Philippe VI", "Jean II", "Charles V", "Charles VI", "Charles VII", "Louis XI"}
// 
// Returns: {"Charles V", "Charles VI", "Charles VII", "Jean II", "Louis XI", "Philippe VI" }
// 
// These are the French monarchs who ruled between 1328 and 1483.
// 
// 5)
// {"Philippe II", "Philip II"}
// 
// Returns: {"Philip II", "Philippe II" }
// 
// "Philippe" and "Philip" are distinct names, and "Philip" is lexicographically smaller than "Philippe".
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

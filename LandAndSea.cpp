#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class LandAndSea
{
public:
	vector <int> howManyIslands(vector <string> seaMap);
};

vvi seaMap;
int N, M;
int cnt;
bool contains[55*55][55*55];
bool vis[55][55];
vi ht;

const int X[] = {1, -1, 0, 0};
const int Y[] = {0, 0, -1, 1};

bool valid(int x, int y) {
	return x >= 0 && x < N && y >= 0 && y < M;
}
/*
void printMap() {
	tr(it, seaMap) {
		tr(jt, *it)
			if(*jt == 0)
				Pf("%4c ", '.');
			else
				Pf("%4d ", *jt);
		cout << endl;
	}
	cout << endl;
}
*/
void connect(int x, int y, int cnt) {
	if(valid(x, y) == false)
		return;
	if(seaMap[x][y] != -1)
		return;

	seaMap[x][y] = cnt;
	forab(i, -1, 1)
		forab(j, -1, 1)
			connect(x+i, y+j, cnt);
}

void coverCheck(int x, int y, int c) {
	if(!valid(x, y))
		return;
	if(seaMap[x][y] == c)
		return;
	if(vis[x][y])
		return;
	vis[x][y] = true;

	forn(i, 4)
		coverCheck(x+X[i], y + Y[i], c);
}

int height(int c) {
	int &ret = ht[c];
	if(ret > -1)
		return ret;
	ret = 0;

	forab(i, 1, cnt)
		if(contains[c][i])
			ret = max(ret, height(i) + 1);
	return ret;
}

vector <int> LandAndSea::howManyIslands (vector <string> _seaMap) 
{
	CL(contains, 0);
	N = _seaMap.size()+2;
	M = _seaMap[0].size()+2;
	seaMap = vvi (N, vi (M, 0));

	forn(i, _seaMap.size())
		forn(j, _seaMap[i].size())
			if(_seaMap[i][j] == 'x')
				seaMap[i+1][j+1] = -1;

//	printMap();

	cnt =  0;
	forn(i, N)	forn(j, M)	if(seaMap[i][j] == -1) {
		CL(vis, 0);
		connect(i, j, ++cnt);
	}
	ht = vi(cnt+1, -1);
//	printMap();

	forab(c, 1, cnt) {
		CL(vis, 0);
		coverCheck(0, 0, c);
		forn(i, N)
			forn(j, M)
				if(seaMap[i][j] != c && vis[i][j] == false && seaMap[i][j] > 0)
					contains[c][seaMap[i][j]] = true;
/*
		cout << c << ": ";
		forab(i, 1, cnt)
			if(contains[c][i] == true)
				write(i);
		cout << endl;
*/
	}
/*
	forab(c, 1, cnt)
		Pf("c = %d, ht = %d\n", c, height(c));
*/
	vector <int> ret (cnt, 0);
	forab(c, 1, cnt)
		ret[height(c)]++;
	
	while(ret.empty() == false && ret.back() == 0)
		ret.pop_back();
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	LandAndSea *obj;
	vector <int> answer;
	obj = new LandAndSea();
	clock_t startTime = clock();
	answer = obj->howManyIslands(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p1[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <int> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"x"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"xxxxx","x...x","x.x.x","x...x","xxxxx"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"xxxxx","x...x","x.x.x","x...x","xxxxx","xxxxx","x...x","x.x.x","x...x","xxxxx"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"..",".."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"............",".......xxxx.","..xxx.x...x.","..x..x..x.x.","..x.x.x...x.","..xx...xxx.."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Bob's father bought him a toy map of islands and seas.  The map is a two-dimensional grid where each cell is either 'x' or '.'.  A sea is defined as a maximal connected group of '.' cells, where two '.' cells are connected if they are vertically or horizontally adjacent.  An island is defined as a maximal connected group of 'x' cells, where two 'x' cells are connected if they are vertically, horizontally, or diagonally adjacent.
// An island has a level of 0 if it contains no other islands.  An island has a level of K+1 if it contains one or more islands and the highest level of a contained island is K.  An island A contains island B if A and B are different and, if you start sailing from any point of island B, you won't be able to sail out of island A (you can sail only horizontally and vertically, but not diagonally).
// 
// 
// For example, the given map below has 5 islands with level 0 (islands 0 - 4 on the right picture) and one island with level 1 (island 5). Please note that starting at island 3, you can not sail outside island 5 (you can not sail diagonally), but its possible get out of island 1 when starting at island 4.
// 
// 
// xxx.x...xxxxx        000.0...11111
// xxxx....x...x        0000....1...1
// ........x.x.x        ........1.4.1
// ..xxxxx.x...x        ..55555.1...1
// ..x...x.xxx.x        ..5...5.111.1
// ..x.x.x...x..        ..5.3.5...1..
// ..x...x...xxx        ..5...5...111
// ...xxxxxx....        ...555555....
// x............        2............
// 
// 
// 
// Given a String[] seaMap, return a int[], where the k-th element is the number of islands of level k.  The int[] must contain exactly (m + 1) elements, where m is the highest level of an island in the map.
// 
// 
// DEFINITION
// Class:LandAndSea
// Method:howManyIslands
// Parameters:vector <string>
// Returns:vector <int>
// Method signature:vector <int> howManyIslands(vector <string> seaMap)
// 
// 
// CONSTRAINTS
// -seaMap will contain between 1 and 50 elements, inclusive.
// -Each element of seaMap will contain between 1 and 50 characters, inclusive.
// -Each element of seaMap will contain the same number of characters.
// -Each element of seaMap will contain only '.' and lowercase 'x' characters.
// 
// 
// EXAMPLES
// 
// 0)
// {"x"}
// 
// Returns: {1 }
// 
// 
// 
// 1)
// {
// "xxxxx",
// "x...x",
// "x.x.x",
// "x...x",
// "xxxxx"
// }
// 
// Returns: {1, 1 }
// 
// 
// 
// 2)
// {
// "xxxxx",
// "x...x",
// "x.x.x",
// "x...x",
// "xxxxx",
// "xxxxx",
// "x...x",
// "x.x.x",
// "x...x",
// "xxxxx"
// }
// 
// Returns: {2, 1 }
// 
// 
// 
// 3)
// {
// "..",
// ".."
// }
// 
// Returns: { }
// 
// 
// 
// 4)
// {
// "............",
// ".......xxxx.",
// "..xxx.x...x.",
// "..x..x..x.x.",
// "..x.x.x...x.",
// "..xx...xxx.."
// }
// 
// Returns: {1, 1 }
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

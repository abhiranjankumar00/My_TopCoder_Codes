#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class MarblesRegroupingEasy
{
public:
	int minMoves(vector <string> boxes);
};

int MarblesRegroupingEasy::minMoves (vector <string> boxes) 
{
	vs box;
	int ret = 0;
	vi cnt;

	tr(it, boxes) {
		int tmp = 0;
		tr(jt, *it)
			if(*jt != '0')
				tmp++;
		cnt.pb(tmp);
		if(tmp == 1)
			box.pb(*it);
	}
	int tmp  = 0;
	tr(it, cnt) {
//		write(*it);
		if(*it >= 2)
			tmp++;
	}
//	cout << endl;
	if(tmp != 0)
		ret += tmp-1;
/*
	tr(it, box)
		cout << *it << endl;
	cout << endl;
*/
	if(box.size() > 0)	forn(j, box[0].size()) {
		int tmp = 0;
		forn(i, box.size())
			if(box[i][j] != '0')
				tmp++;
		if(tmp>1)
			ret += tmp-1;
	}
	if(tmp == 0)
		if(ret > 0)
			ret--;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	MarblesRegroupingEasy *obj;
	int answer;
	obj = new MarblesRegroupingEasy();
	clock_t startTime = clock();
	answer = obj->minMoves(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"20","11"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"11","11","10"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"10","10","01","01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"11","11","11","10","10","01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"020008000070","000004000000","060000600000","006000000362","000720000000","000040000000","004009003000","000800000000","020030003000","000500200000","000000300000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// John is a marble collector. He keeps his marbles in boxes. He also likes to keep things in order.
// 
// 
// 
// One day, his younger brother was playing with the marbles.  After he was done, he put all the marbles back in boxes, but he did it randomly, so certain boxes might now contain marbles of different colors. John wants him to regroup the marbles so that the grouping satisfies the following restrictions:
// 
// 
// 
// At most one box, called the joker box, may contain marbles of different colors. We can choose any box as a joker box.
// Every box except the joker box must either be empty or only contain marbles of the same color.
// All marbles of the same color, except those in the joker box, must be in the same box. It's possible that all marbles of the same color are in the joker box.
// 
// 
// 
// You are given a vector <string> boxes, where the j-th digit of the i-th element is the number of marbles of color j in the i-th box. Return the minimal number of moves necessary to regroup the marbles, where each move consists of taking any number of marbles from one box (not necessarily of the same color) and putting them into another.
// 
// 
// DEFINITION
// Class:MarblesRegroupingEasy
// Method:minMoves
// Parameters:vector <string>
// Returns:int
// Method signature:int minMoves(vector <string> boxes)
// 
// 
// CONSTRAINTS
// -boxes will contain between 1 and 50 elements, inclusive.
// -Each element of boxes will contain between 1 and 50 characters, inclusive.
// -All elements of boxes will contain the same number of characters.
// -Each element of boxes will contain only digits ('0'-'9').
// 
// 
// EXAMPLES
// 
// 0)
// {"20",
//  "11"}
// 
// Returns: 0
// 
// Let box 1 be the joker box. All marbles of color 0, except those in the joker box, are in box 0. Box 0 contain only marbles of the color 0. So, all restrictions are already satisfied.
// 
// 
// 1)
// {"11",
//  "11",
//  "10"}
// 
// Returns: 1
// 
// There are several possible solutions:
// 
// Move all marbles from box 0 into box 1. Box 1 is the joker box.
// Move all marbles from box 1 into box 0. Box 0 is the joker box.
// Move the marble of color 0 from box 0 into box 1 or 2. Box 1 is the joker box.
// Move the marble of color 0 from box 1 into box 0 or 2. Box 0 is the joker box.
// 
// 
// 
// 2)
// {"10",
//  "10",
//  "01",
//  "01"}
// 
// Returns: 1
// 
// Let box 0 be the joker box. Now we only need to group all marbles of  color 1 into one box.
// 
// 3)
// {"11",
//  "11",
//  "11",
//  "10",
//  "10",
//  "01"}
// 
// Returns: 3
// 
// 
// 
// 4)
// {"020008000070",
//  "000004000000",
//  "060000600000",
//  "006000000362",
//  "000720000000",
//  "000040000000", 
//  "004009003000",
//  "000800000000", 
//  "020030003000",
//  "000500200000",
//  "000000300000"}
// 
// Returns: 6
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

struct Node {
	ST st;
	int mod;
	Node(ST _st, int _mod) {
		st = _st;
		mod = _mod;
	}
};

bool vis[20000];

class MultiplesWithLimit
{
public:
	string minMultiples(int N, vector <int> forbiddenDigits)
	{
		CL(vis, false);

		ST num[10];
		forn(i, 10) {
			SS ss;	ss << i;
			num[i] = ss.str();
		}

		bool in[11];
		CL(in, -1);
		tr(it, forbiddenDigits)
			in[*it] = false;

		queue<Node> q;

		forab(i, 1, 9)	if(in[i])
			q.push(Node(num[i], i%N)), vis[i%N] = true;

		while(!q.empty()) {
			Node n = q.front();	q.pop();

			if(n.mod == 0) {
				if(n.st.length() < 9)
					return n.st;
				else {
					SS ss;	ss << n.st.length();	ST p = ss.str();
					return n.st.substr(0, 3) + "..." + n.st.substr(n.st.length() - 3, 3) + "(" + p + " digits)";
				}
			}

			forn(i, 10)	if(in[i] && !vis[(n.mod*10 + i) % N] ) {
				q.push(Node(n.st + num[i], (n.mod*10 + i) % N));
				vis[(n.mod*10 + i)%N] = true;
			}
		}

		return "IMPOSSIBLE";
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	MultiplesWithLimit *obj;
	string answer;
	obj = new MultiplesWithLimit();
	clock_t startTime = clock();
	answer = obj->minMultiples(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = 8;
	int t1[] = {2,3,4,5,6,7,8,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "1000";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 9;
	int t1[] = {1,3,4,5,6,7,8,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "222...222(9 digits)";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 524;
	int t1[] = {5,2,4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "3668";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 10000;
	int t1[] = {0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "IMPOSSIBLE";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 1;
	int t1[] = {0,1,2,3,4,5,6,7,8,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "IMPOSSIBLE";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Your task is to find the minimal positive integer x such that:
// 
// 1. x is an integer multiple of N.
// 
// 2. The decimal representation of x doesn't contain any forbidden digits.
// 
// You will be given the forbidden digits as a vector <int> forbiddenDigits.
// 
// 
// 
// If there is no solution, you should return the string "IMPOSSIBLE" (quotes for clarity). 
// 
// If there is a solution and its number of digits is strictly less than 9, you should return a string containing the integer x in base 10, with no leading zeros.
// 
// Otherwise, you should return a string of the form "abc...def(g digits)" (quotes for clarity). In the return value, abc are the first three digits of the smallest valid integer x, def are its last three digits, and g is the number of digits in x (a base-10 integer with no leading zeros). 
// 
// DEFINITION
// Class:MultiplesWithLimit
// Method:minMultiples
// Parameters:int, vector <int>
// Returns:string
// Method signature:string minMultiples(int N, vector <int> forbiddenDigits)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 10000, inclusive.
// -forbiddenDigits will contain between 0 and 10 elements, inclusive.
// -Each element of forbiddenDigits will be between 0 and 9, inclusive.
// -The elements of forbiddenDigits will be pairwise distinct.
// 
// 
// EXAMPLES
// 
// 0)
// 8
// {2,3,4,5,6,7,8,9}
// 
// Returns: "1000"
// 
// The smallest positive multiple of 8 that only contains digits 0 and 1 is 1000.
// 
// 1)
// 9
// {1,3,4,5,6,7,8,9}
// 
// Returns: "222...222(9 digits)"
// 
// 
// 
// 2)
// 524
// {5,2,4}
// 
// Returns: "3668"
// 
// 
// 
// 3)
// 10000
// {0}
// 
// Returns: "IMPOSSIBLE"
// 
// 
// 
// 4)
// 1
// {0,1,2,3,4,5,6,7,8,9}
// 
// Returns: "IMPOSSIBLE"
// 
// 
// 
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

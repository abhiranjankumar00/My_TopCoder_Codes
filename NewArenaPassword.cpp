#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class NewArenaPassword
{
public:
	int minChange(string oldPassword, int K);
};

int par[55];

int findSet(int u) {
	return par[u] = u == par[u] ? u : findSet(par[u]);
}

void mergeSet(int u, int v) {
	int pu = findSet(u), pv = findSet(v);
	par[pu] = pv;
}

int NewArenaPassword::minChange (string s, int K) 
{
	forn(i, 55)
		par[i] = i;

	for(int i  = 0, j = s.size() - K; i < K; i++, j++)
		mergeSet(i, j);

//	map <int vi > m;
	forn(i, s.size()) {
		Pf("(%d: %d) , ", i, findSet(i));
	}

	int ret = 0;
	forn(i, 55) {
		map <char, int> cnt;
		int tmp = 0;
		forn(j, s.size())	if(findSet(j) == i) {
			cnt[s[j]]++;
			tmp++;
		}
		int mx = 0;
		tr(it, cnt)
			mx = max(mx, it->second);
		ret += tmp - mx;
	}

	return ret;

	/*
	s = _s;
	K = _K;
	int ret = 0;

	if(s.size() >= 2*K){
		for(int i = 0, j = s.size() - K; i < K; i++, j++) {
			if(s[i] != s[j])
				ret++;
		}
		return ret;
	}
	
	return ret = -1;
*/
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << p1;
	cout << "]" << endl;
	NewArenaPassword *obj;
	int answer;
	obj = new NewArenaPassword();
	clock_t startTime = clock();
	answer = obj->minChange(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = "topcoderopen";
	p1 = 5;
	p2 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "puyopuyo";
	p1 = 4;
	p2 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "loool";
	p1 = 3;
	p2 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "arena";
	p1 = 5;
	p2 = 0;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "amavckdkz";
	p1 = 7;
	p2 = 5;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "abcdefghijklmnoabcdeflkdjfsoiermnfsdljkldjlkjalkdd ";
	p1 = 48;
	all_right = KawigiEdit_RunTest(5, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are a huge fan of an online programming contest called SRM (Special Round Match). To participate in an SRM contest, you must first download an applet called Arena, log in to the Arena by entering your username and password, and start competing.
// 
// Recently, to avoid hackers' attacks on the Arena, SRM imposes a new rule for the users' passwords. From now on, the first K characters of each user's password must match its last K characters. In this way, if someone enters a password with different first and last K characters repeatedly, it can be considered an attack from hackers.
// 
// However, you love your old password and do not want to change many characters from it. You are given a string oldPassword representing your old password, and an int K. Return the minimum number of characters of oldPassword that must be changed so that the string containing the first K characters of oldPassword is equal to the string containing the last K characters of oldPassword.
// 
// DEFINITION
// Class:NewArenaPassword
// Method:minChange
// Parameters:string, int
// Returns:int
// Method signature:int minChange(string oldPassword, int K)
// 
// 
// CONSTRAINTS
// -oldPassword will contain between 1 and 50 characters, inclusive.
// -Each character of oldPassword will be a lowercase letter 'a' - 'z'.
// -K will be between 1 and the number of characters of oldPassword, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "topcoderopen"
// 5
// 
// Returns: 3
// 
// A possible solution is changing your password into "topcndetopcn". To do this, you must change the 4th, 7th, and 10th characters (0-based) of "topcoderopen".
// 
// 1)
// "puyopuyo"
// 4
// 
// Returns: 0
// 
// Your old password already satisfies the new rule.
// 
// 2)
// "loool"
// 3
// 
// Returns: 1
// 
// The first and the last K characters can overlap. In this case, the only optimal solution is to change your password into "lolol".
// 
// 3)
// "arena"
// 5
// 
// Returns: 0
// 
// 
// 
// 4)
// "amavckdkz"
// 7
// 
// Returns: 5
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

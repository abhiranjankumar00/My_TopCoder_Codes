#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define endl 		("\n")

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define Pf		printf
#define	Sf		scanf

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

/*
#ifdef DEBUG
	#undef DEBUG
#endif
#define DEBUG
*/

class NinjaTurtles
{
public:
	int countOpponents(int P, int K);
};

int binarySearch(int l, int r, int P, int K) {
	if(l == r) {
		return 3*(l/K) + l/3 == P ? l : -1;
	}
	int n = (l+r)/2;

	if(3*(n/K) + n/3 >= P)
		return binarySearch(l, n, P, K);
	return binarySearch(n+1, r, P, K);
}

int NinjaTurtles::countOpponents (int P, int K) 
{
	return binarySearch(1, 1e9, P, K);
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	NinjaTurtles *obj;
	int answer;
	obj = new NinjaTurtles();
	clock_t startTime = clock();
	answer = obj->countOpponents(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 5;
	p1 = 4;
	p2 = 6;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 1;
	p1 = 4;
	p2 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 13;
	p1 = 6;
	p2 = -1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 13;
	p1 = 17;
	p2 = 30;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 122;
	p1 = 21;
	p2 = 258;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The Ninja Turtles often battle the Foot Clan ninjas. The Turtles celebrate each victory with a pizza party. The amount of pizza they eat depends on the number of opponents they have defeated. Denote the number of defeated opponents as N. Three of the four Turtles have a moderate appetite and only consume floor(N / K) pizzas each. The fourth Turtle is always hungry and eats floor(N / 3) pizzas.
// 
// 
// 
// You are given ints P and K, where P is the total number of pizzas the Turtles ate after a battle. If there exists at least one value of N such that after defeating N opponents the Turtles would eat exactly P pizzas at the party, return the smallest such N. Otherwise, return -1.
// 
// DEFINITION
// Class:NinjaTurtles
// Method:countOpponents
// Parameters:int, int
// Returns:int
// Method signature:int countOpponents(int P, int K)
// 
// 
// NOTES
// -floor(X) is equal to the largest integer which is less or equal to X.
// 
// 
// CONSTRAINTS
// -P will be between 1 and 1,000,000, inclusive.
// -K will be between 4 and 100, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 5
// 4
// 
// Returns: 6
// 
// If the Turtles defeated 6 opponents, three of the four Turtles would eat floor(6 / 4) = 1 pizza each and the fourth one would eat floor(6 / 3) = 2 pizzas, which makes 5 pizzas in total.
// Note that you always have to return the smallest possible N. For example, in this scenario for N = 7 the Turtles would also eat 5 pizzas, but 7 is not a correct return value, because 6 is less than 7.
// 
// 1)
// 1
// 4
// 
// Returns: 3
// 
// After a fight with three opponents, only the hungry Turtle would eat a pizza.
// 
// 2)
// 13
// 6
// 
// Returns: -1
// 
// There is no value of N such that if the Turtles battle N opponents, they eat exactly 13 pizzas for K = 6.
// 
// 3)
// 13
// 17
// 
// Returns: 30
// 
// For K = 17, after defeating 30 opponents the Turtles will eat 13 pizzas in total.
// 
// 4)
// 122
// 21
// 
// Returns: 258
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

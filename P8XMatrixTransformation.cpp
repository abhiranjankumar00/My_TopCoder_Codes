#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

int count_(vs & v) {
	int ret = 0;
	forn(i, v.size())	forn(j, v[i].size())	if(v[i][j] == '1')
		ret++;
	return ret;
}

class P8XMatrixTransformation
{
public:
	string solve(vector <string> orig, vector <string> ta)
	{
		return count_(orig) == count_(ta) ? "YES" : "NO";
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	P8XMatrixTransformation *obj;
	string answer;
	obj = new P8XMatrixTransformation();
	clock_t startTime = clock();
	answer = obj->solve(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	string p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"01","11"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"11","10"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "YES";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"0111","0011"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1011","1100"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "YES";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"0"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "NO";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"1111","1111","0000","0000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1111","1111","0000","0000"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "YES";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"0110","1001","0110"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1111","0110","0000"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "YES";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"0000","1111","0000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1111","0000","1111"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "NO";
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.
// 
// You are given two vector <string>s original and target, which are two rectangular matrices with the same dimensions. Each character in the matrices will be either '0' or '1'. You want to transform original into target. You are only allowed to use one type of operations: Pick either a single row or a single column, and permute all its characters arbitrarily. You may use as many operations as you want to, one after another.
// 
// Is it possible to transform original into target by using the allowed operations only? Return "YES" if it's possible, "NO" otherwise (quotes for clarity).
// 
// DEFINITION
// Class:P8XMatrixTransformation
// Method:solve
// Parameters:vector <string>, vector <string>
// Returns:string
// Method signature:string solve(vector <string> original, vector <string> target)
// 
// 
// NOTES
// -Permuting the characters means rearranging them into a new order.
// 
// 
// CONSTRAINTS
// -original will contain between 1 and 50 elements, inclusive.
// -Each element of original will contain between 1 and 50 characters, inclusive.
// -All the elements of original will contain the same number of characters.
// -Each character in each element of original will be either '0' or '1'.
// -target will contain exactly R elements, where R is the number of elements in original.
// -Each element of target will contain exactly C characters, where C is the number of characters in original[0].
// -Each character in each element of target will be either '0' or '1'.
// 
// 
// EXAMPLES
// 
// 0)
// {"01"
// ,"11"}
// {"11"
// ,"10"}
// 
// Returns: "YES"
// 
// For example, you can apply the following operations:
// 
// That is, you can first permute the first row and then the second column in the way shown above.
// 
// 1)
// {"0111"
// ,"0011"}
// {"1011"
// ,"1100"}
// 
// Returns: "YES"
// 
// 
// 
// 2)
// {"0"}
// {"1"}
// 
// Returns: "NO"
// 
// 
// 
// 3)
// {"1111"
// ,"1111"
// ,"0000"
// ,"0000"}
// {"1111"
// ,"1111"
// ,"0000"
// ,"0000"}
// 
// Returns: "YES"
// 
// 
// 
// 4)
// {"0110"
// ,"1001"
// ,"0110"}
// {"1111"
// ,"0110"
// ,"0000"}
// 
// Returns: "YES"
// 
// 
// 
// 5)
// {"0000"
// ,"1111"
// ,"0000"}
// {"1111"
// ,"0000"
// ,"1111"}
// 
// Returns: "NO"
// 
// 
// 
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

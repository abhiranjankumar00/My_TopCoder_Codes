#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	cl(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

//#define debug(x)
#define debug(x)	cout << #x << " = " << x << "\n"

class PalindromeMaker2
{
public:
	string make(string baseString);
};

string PalindromeMaker2::make (string baseString) 
{
	map < char, int > cnt;
	cnt.clear();

	for(auto it = (baseString).begin(); it != (baseString).end(); ++it) {
		cnt[*it]++;
	}

	int oddCount= 0;
	char odd;
	for(auto it = (cnt).begin(); it != (cnt).end(); ++it) {
		if(it->second % 2 ==1) {
			oddCount++;
			odd = it->first;
		}
	}
	if(oddCount > 1)
		return "";
	string ret = "";
	for(auto it = (cnt).begin(); it != (cnt).end(); ++it) {
		for(int i = 0; i < it->second/2; ++i) {
			ret += it->first;
		}
	}
	string tmp = ret;
	reverse(tmp.begin(), tmp.end() );
	if(oddCount == 1)
		ret += odd;
	ret += tmp;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	PalindromeMaker2 *obj;
	string answer;
	obj = new PalindromeMaker2();
	clock_t startTime = clock();
	answer = obj->make(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	string p1;
	
	{
	// ----- test 0 -----
	p0 = "AABB";
	p1 = "ABBA";
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "AAABB";
	p1 = "ABABA";
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "ABACABA";
	p1 = "AABCBAA";
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "ABCD";
	p1 = "";
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// A palindrome is a string that is spelled the same forward and backward. We want to rearrange letters of the given string baseString so that it becomes a palindrome.
// You will be given a string baseString. Return the palindrome that can be made from baseString. When more than one palindrome can be made, return the lexicographically earliest (i.e., the one that occurs first in alphabetical order). Return "" (the empty string) if no palindromes can be made from baseString.
// 
// 
// DEFINITION
// Class:PalindromeMaker2
// Method:make
// Parameters:string
// Returns:string
// Method signature:string make(string baseString)
// 
// 
// CONSTRAINTS
// -baseString will contain between 1 and 50 characters, inclusive. 
// -Each character in baseString will be an uppercase letter ('A'-'Z').
// 
// 
// EXAMPLES
// 
// 0)
// "AABB"
// 
// Returns: "ABBA"
// 
// 
// 
// 1)
// "AAABB"
// 
// Returns: "ABABA"
// 
// 
// 
// 2)
// "ABACABA"
// 
// Returns: "AABCBAA"
// 
// 
// 
// 3)
// "ABCD"
// 
// Returns: ""
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

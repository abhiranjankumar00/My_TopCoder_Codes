#include <bits/stdc++.h>
using namespace std;

class PalindromeMatrix
{
public:
	int minChange(vector <string> A, int rowCount, int columnCount);
};

int PalindromeMatrix::minChange (vector <string> A, int rowCount, int columnCount) 
{
	int ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1 << "," << p2;
	cout << "]" << endl;
	PalindromeMatrix *obj;
	int answer;
	obj = new PalindromeMatrix();
	clock_t startTime = clock();
	answer = obj->minChange(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	int p1;
	int p2;
	int p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"0000","1000","1100","1110"};
	p1 = 2;
	p2 = 2;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"0000","1000","1100","1110"};
	p1 = 3;
	p2 = 2;
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"01","10"};
	p1 = 1;
	p2 = 1;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"1110","0001"};
	p1 = 0;
	p2 = 0;
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"01010101","01010101","01010101","01010101","01010101","01010101","01010101","01010101"};
	p1 = 2;
	p2 = 3;
	p3 = 8;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {"000000000000","011101110111","010001010101","010001010101","011101010101","010101010101","010101010101","011101110111","000000000000","000000000000"};
	p1 = 5;
	p2 = 9;
	p3 = 14;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {"11111101001110","11000111111111","00010101111001","10110000111111","10000011010010","10001101101101","00101010000001","10111010100100","11010011110111","11100010110110","00100101010100","01001011001000","01010001111010","10100000010011"};
	p1 = 6;
	p2 = 8;
	p3 = 31;
	all_right = (disabled || KawigiEdit_RunTest(6, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Note that the memory limit for all tasks in this SRM is 256 MB.
// 
// 
// Fox Ciel has a matrix A that consists of N rows by M columns.
// Both N and M are even.
// Each element of the matrix is either 0 or 1.
// The rows of the matrix are numbered 0 through N-1 from top to bottom, the columns are numbered 0 through M-1 from left to right.
// The element in row i, column j is denoted A(i, j).
// You are given a vector <string> A that describes the matrix A.
// The character A[i][j] is '1' if A(i, j)=1 and it is '0' otherwise.
// 
// 
// 
// A palindrome is a string that reads the same forwards and backwards.
// For example, "1001" and "0111001110" are palindromes while "1101" and "000001" are not.
// 
// 
// 
// Some rows and some columns in Ciel's matrix may be palindromes.
// For example, in the matrix below both row 0 and column 3 are palindromes.
// (Row 0 is the palindrome "0000", column 3 is the palindrome "0110".)
// 
// 
// 0000
// 0011
// 0111
// 1110
// 
// 
// 
// You are also given two ints: rowCount and columnCount.
// Ciel wants her matrix A to have at least rowCount rows that are palindromes, and at the same time at least columnCount columns that are palindromes.
// If this is currently not the case, she can change A by changing some of the elements (from '0' to '1' or vice versa).
// Compute and return the smallest possible number of elements she needs to change in order to reach her goal.
// 
// 
// DEFINITION
// Class:PalindromeMatrix
// Method:minChange
// Parameters:vector <string>, int, int
// Returns:int
// Method signature:int minChange(vector <string> A, int rowCount, int columnCount)
// 
// 
// CONSTRAINTS
// -N and M will be between 2 and 14, inclusive.
// -N and M will be even.
// -A will contain N elements.
// -Each element of A will contain M characters.
// -Each character of A will be either '0' or '1'.
// -rowCount will be between 0 and N.
// -columnCount will be between 0 and M.
// 
// 
// EXAMPLES
// 
// 0)
// {"0000"
// ,"1000"
// ,"1100"
// ,"1110"}
// 2
// 2
// 
// Returns: 1
// 
// An optimal solution is to change A(3, 0) to 0. Then we will have palindromes in two rows (0 and 3), and in two columns (0 and 3).
// 
// 1)
// {"0000"
// ,"1000"
// ,"1100"
// ,"1110"}
// 3
// 2
// 
// Returns: 3
// 
// This is similar to the previous example, but in this case we must have three row palindromes. 
// An optimal solution is to change A(1, 0), A(2, 0) and A(3, 0) to 0.
// 
// 2)
// {"01"
// ,"10"}
// 1
// 1
// 
// Returns: 1
// 
// 
// 
// 3)
// {"1110"
// ,"0001"}
// 0
// 0
// 
// Returns: 0
// 
// Here, we do not have to change A at all.
// 
// 4)
// {"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"}
// 2
// 3
// 
// Returns: 8
// 
// 
// 
// 5)
// {"000000000000"
// ,"011101110111"
// ,"010001010101"
// ,"010001010101"
// ,"011101010101"
// ,"010101010101"
// ,"010101010101"
// ,"011101110111"
// ,"000000000000"
// ,"000000000000"}
// 5
// 9
// 
// Returns: 14
// 
// 
// 
// 6)
// {"11111101001110"
// ,"11000111111111"
// ,"00010101111001"
// ,"10110000111111"
// ,"10000011010010"
// ,"10001101101101"
// ,"00101010000001"
// ,"10111010100100"
// ,"11010011110111"
// ,"11100010110110"
// ,"00100101010100"
// ,"01001011001000"
// ,"01010001111010"
// ,"10100000010011"}
// 6
// 8
// 
// Returns: 31
// 
// 
// 
// END KAWIGIEDIT TESTING

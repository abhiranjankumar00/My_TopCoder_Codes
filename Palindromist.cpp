#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define endl 		("\n")

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define Pf		printf
#define	Sf		scanf

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

/*
#ifdef DEBUG
	#undef DEBUG
#endif
#define DEBUG
*/

class Palindromist
{
public:
	string palindrome(string text, vector <string> words);
};

int par[111];
int G[111][111];

void dfs(int v = 0, int p = 0) {
	if(par[v] > -1)
		return;
	par[v] = p;
	forab(n, v+1, 105)
		if(G[v][n])
			dfs(n, v);
}

string solve(string text, const vs& words) {
	CL(par, -1);
	CL(G, 0);
	int N = text.size();
	DEBUG(text);
	forn(i, text.size())
		for(int j = 1; i+j <= text.size(); j++)
			if(find(words.begin(), words.end(), text.substr(i, j)) != words.end())
				G[i][i+j] = true;
/*
	if(false ) {
		forn(i, N)
			forab(j, 0, N)
				if(G[i][j])
					Pf("(%d->%d), ", i, j);
		cout << endl;
	}
*/
	dfs();

	if(par[N] == -1 )
		return "";

	int v= N;
	vs ret;
	while(v != 0) {
		ret.pb(text.substr(par[v], v - par[v]));
		v = par[v];
	}
	reverse(all(ret));
	string ans = "";
	forn(i, ret.size()) {
		if(i != 0)
			ans += " ";
		ans += ret[i];
	}
/*
	cout << "ret = ";
	tr(it, ret)
		cout << *it << " ";
	cout << endl;
*/
/*
	forn(i, N+1)
		write(par[i]);
	cout << endl;
*/
//	cout << "ans = |" << ans << "|\n";
//	cout << "==================" <<  endl;
	return ans;
}

string Palindromist::palindrome (string text, vector <string> words) 
{
	string reverseText = text;
	reverse(all(reverseText));
	string text1 = text + reverseText;
	string text2 = text + reverseText.substr(1);

	string ret1 = solve(text1, words);
	string ret2 = solve(text2, words);
	if(ret1 == "" && ret2 == "")
		return ret1;

	if(ret1 == "" && ret2 != "")
		return ret2;
	if(ret2 == "" && ret1 != "")
		return ret1;
	return min(ret1, ret2);
	
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, vector <string> p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	Palindromist *obj;
	string answer;
	obj = new Palindromist();
	clock_t startTime = clock();
	answer = obj->palindrome(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <string> p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = "AMANAPLANAC";
	string t1[] = {"A","CANAL","MAN","PANAMA","PLAN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "A MAN A PLAN A CANAL PANAMA";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "AAAAA";
	string t1[] = {"AA","A","AAA"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "A A A A A A A A A";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "CBA";
	string t1[] = {"CBABC","CBAABC"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "CBAABC";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "RACEFAST";
	string t1[] = {"AR","CAR","FAST","RACE","SAFE","CEFA","ACE","STTS","AFEC"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "RACE FAST SAFE CAR";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "AABAABA";
	string t1[] = {"AA","AAB","BAA","BAB"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "AA BAA BAA BAA BAA";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "STRAWNOTOOSTUPIDAF";
	string t1[] = {"WARTS","I","TOO","A","FAD","STUPID","STRAW","PUT","NO","ON","SOOT"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "STRAW NO TOO STUPID A FAD I PUT SOOT ON WARTS";
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = "AAAAA";
	string t1[] = {"AAAA"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "";
	all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	p0 = "A";
	string t1[] = {"A","AA"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "A";
	all_right = KawigiEdit_RunTest(7, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// A palindrome is a phrase that reads the same forward and backward (ignoring spaces).  Given the first half of a palindrome (as described below), you must return a complete palindrome that contains only words from a given set of legal words.   The returned palindrome must be a phrase where words are separated by single spaces.
// 
// 
// 
// You will be given the first half of the palindrome as a string text containing only letters and no spaces.  There are two complete palindromes that can be created from this first half.  For example, given "ABC", you could produce either "ABCCBA" or "ABCBA" as the complete palindrome.  You must then insert spaces into the complete palindrome such that all the words in the phrase exist in the vector <string> words
// 
// 
// 
// For example, given the list of words { "A", "CANAL", "MAN", "PANAMA", "PLAN" }, and the text "AMANAPLANAC", your method would return the string "A MAN A PLAN A CANAL PANAMA".
// 
// 
// 
// If no palindrome can be made, your method should return "".
// If more than one palindrome can be made, return the one that comes first lexicographically (please note that ' ' comes before all letters).
// 
// 
// 
// DEFINITION
// Class:Palindromist
// Method:palindrome
// Parameters:string, vector <string>
// Returns:string
// Method signature:string palindrome(string text, vector <string> words)
// 
// 
// CONSTRAINTS
// -text will contain between 1 and 50 characters, inclusive.
// -text will contain only uppercase letters ('A'-'Z').
// -words will contain between 1 and 50 elements, inclusive.
// -Each element of words will contain between 1 and 50 characters, inclusive.
// -Each element of words will contain only uppercase letters ('A'-'Z').
// 
// 
// EXAMPLES
// 
// 0)
// "AMANAPLANAC"
// { "A", "CANAL", "MAN", "PANAMA", "PLAN" }
// 
// Returns: "A MAN A PLAN A CANAL PANAMA"
// 
// 1)
// "AAAAA"
// { "AA", "A", "AAA" }
// 
// Returns: "A A A A A A A A A"
// 
// 2)
// "CBA"
// { "CBABC", "CBAABC" }
// 
// Returns: "CBAABC"
// 
// 3)
// "RACEFAST"
// { "AR", "CAR", "FAST", "RACE", "SAFE", "CEFA", "ACE", "STTS", "AFEC" }
// 
// Returns: "RACE FAST SAFE CAR"
// 
// 4)
// "AABAABA"
// { "AA", "AAB", "BAA", "BAB" }
// 
// Returns: "AA BAA BAA BAA BAA"
// 
// 5)
// "STRAWNOTOOSTUPIDAF"
// { "WARTS", "I", "TOO", "A", "FAD", "STUPID", "STRAW", "PUT", "NO", "ON", "SOOT" }
// 
// Returns: "STRAW NO TOO STUPID A FAD I PUT SOOT ON WARTS"
// 
// 6)
// "AAAAA"
// { "AAAA" }
// 
// Returns: ""
// 
// 7)
// "A"
// { "A", "AA" }
// 
// Returns: "A"
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

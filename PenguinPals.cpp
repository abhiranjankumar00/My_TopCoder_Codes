#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define endl 		("\n")

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define Pf		printf
#define	Sf		scanf

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

/*
#ifdef DEBUG
	#undef DEBUG
#endif
#define DEBUG
*/

class PenguinPals
{
public:
	int findMaximumMatching(string colors);
};

/*
map <string, int> m;
int solve(string st) {
	int N = st.size();
	if(N <= 1)
		return 0;
	if(N == 2)
		return st[0] == st[1] ? 1 : 0;

	map <string, int> :: iterator it = m.find(st);

	if(it != m.end())
		return it->second;

	int ret = 0;

	forn(i, N)	forab(j, i+1, N-1)	if(st[i] == st[j]) {
		if(i + 1 == j) {
			if(i == 0)
				ret = max(ret, 1 + solve(st.substr(2)));
			else if(j == N-1)
				ret = max(ret, 1 + solve(st.substr(0, i)));
			else
				ret = max(ret, 1 + solve( st.substr(j+1) + st.substr(0, i) ));
		}
		else if(i == 0 && j == N-1)
			ret = max(ret, 1 + solve( st.substr(1, N-2) ) );
		else if(i == 0) 
			ret = max(ret, 1 + solve(st.substr(1, j-1)) + solve(st.substr(j+1)));
		else if(j == N-1)
			ret = max(ret, 1 + solve(st.substr(0, i)) + solve( st.substr(i+1, j-i-1) ) );
		else
			ret = max(ret, 1 + solve(st.substr(i+1, j-i-1)) + solve(st.substr(j+1) + st.substr(0, i)));
	}

	return m[st] = ret;
}
*/

map < pair <int, int>, int> m;
int N;
string st;

int solve(int b, int e) {
	if(b == e)
		return 0;
	if( (b+1) % N == e)
		return st[b] == st[e] ? 1 : 0;

	map < pair <int, int>, int> :: iterator it = m.find(mp(b, e));

	if(it != m.end())
		return it->second;

	int ret = 0;

	for(int i = b; i != e; i = (i+1)%N) {
		int j = i;
		do {
			j = (j+1)%N;

			if(st[i] == st[j]) {
				if(j = (i+1)%N) {
					if(i == b) {
						ret = max(ret, 1 + solve((j+1)%N, e));
					}
					else if(j == e)
						ret = max(ret, 1 + solve(b, (j-1+N)%N));
				}
			}
			
		} while(j != e);
	}

	return m[mp(b, e)] = ret;
}

int PenguinPals::findMaximumMatching (string colors) 
{
	m.clear();
	st = colors;
	N = st.size();

	int ret = 0;
	

	forn(i, N)	forab(j, i+1, N-1)	if(st[i] == st[j]) {
		if(j == i+1) 
			ret = max(ret, 1 + solve( (j+1)%N, (i+N-1)%N ));
		else
			ret = max(ret, 1 + solve( (i+1)%N, (j+N-1)%N ) + solve( (j+1)%N, (i+N-1)%N ));
	}

	return ret;
/*
	m.clear();
	return solve(colors);
*/
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	PenguinPals *obj;
	int answer;
	obj = new PenguinPals();
	clock_t startTime = clock();
	answer = obj->findMaximumMatching(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	
	{
	// ----- test 0 -----
	p0 = "RRBRBRBB";
	p1 = 3;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "RRRR";
	p1 = 2;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "BBBBB";
	p1 = 2;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "RBRBRBRBR";
	p1 = 4;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "RRRBRBRBRBRB";
	p1 = 5;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "R";
	p1 = 0;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = "RBRRBBRB";
	p1 = 3;
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	p0 = "RBRBBRBRB";
	p1 = 4;
	all_right = KawigiEdit_RunTest(7, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 8 -----
	p0 = "RBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRBRB";
	all_right = KawigiEdit_RunTest(8, p0, false, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Penguin Pals is a match making service that matches penguins to new friends, using the following procedure:
// 
// Each penguin is asked a single question: "Do you prefer the color blue, or the color red?"
// All penguins are arranged so that they stand on a circle, equally spaced. 
// The organizers draw some straight lines, connecting some pairs of penguins. Each penguin may only be connected to at most one other penguin. Two penguins cannot be connected if they prefer a different color.
// Each penguin who is connected to some other penguin follows the line to find their match.
// 
// 
// 
// 
// The only problem with the above system was that it allowed penguins to collide if two lines crossed each other.
// Therefore, a new additional rule was adopted: no two lines may cross.
// Penguin Pals now has some penguins arranged on a circle (after step 2 of the above procedure).
// They need to know the maximum number of pairs of penguins they can create.
// 
// 
// 
// You are given a string colors whose i-th character represents the prefered color of the i-th penguin (0-based index) in the circular arrangement. The i-th character is 'R' if the i-th penguin prefers red and 'B' if the i-th penguin prefers blue. Return the maximum number of matched pairs that can be formed.
// 
// 
// DEFINITION
// Class:PenguinPals
// Method:findMaximumMatching
// Parameters:string
// Returns:int
// Method signature:int findMaximumMatching(string colors)
// 
// 
// CONSTRAINTS
// -colors will contain between 1 and 50 characters, inclusive.
// -Each character of colors will be either 'R' or 'B'.
// 
// 
// EXAMPLES
// 
// 0)
// "RRBRBRBB"
// 
// Returns: 3
// 
// In this picture the penguins have been colored in their preferred color. 
// 
// 
// 
// 1)
// "RRRR"
// 
// Returns: 2
// 
// 
// 
// 2)
// "BBBBB"
// 
// Returns: 2
// 
// 
// 
// 3)
// "RBRBRBRBR"
// 
// Returns: 4
// 
// 
// 
// 4)
// "RRRBRBRBRBRB"
// 
// Returns: 5
// 
// 
// 
// 5)
// "R"
// 
// Returns: 0
// 
// 
// 
// 6)
// "RBRRBBRB"
// 
// Returns: 3
// 
// 
// 
// 7)
// "RBRBBRBRB"
// 
// Returns: 4
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

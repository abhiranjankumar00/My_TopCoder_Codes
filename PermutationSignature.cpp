#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef string ST;
typedef stringstream SS;

#define pb	push_back
#define mp	make_pair
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0; i < n; i++)
#define forab(i, a, b)	for(int i = a; i <= b; i++)
#define rep(i, a, b)	for(int i = a; i>=b; i--)

class PermutationSignature
{
public:
	vector <int> reconstruct(string sign)
	{
		sign = " " + sign;
		vector <int> ret(sign.length());
		
		ret[0] = 1;
		int m = 1, idx = 0;
		
		forab(i, 1, sign.length()-1)
		{
			m++;
			if(sign[i] == 'I')
			{
				ret[i] = m;
				idx = i;				
			}
			else
			{
				forab(j, idx, i)
					ret[j] ++;
				ret[i] = ret[i-1] -1 ;	
			}
			
		}
		
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	PermutationSignature *obj;
	vector <int> answer;
	obj = new PermutationSignature();
	clock_t startTime = clock();
	answer = obj->reconstruct(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p1[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <int> p1;
	
	{
	// ----- test 0 -----
	p0 = "IIIII";
	int t1[] = {1,2,3,4,5,6};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "DI";
	int t1[] = {2,1,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "IIIID";
	int t1[] = {1,2,3,4,6,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "DIIDID";
	int t1[] = {2,1,3,5,4,7,6};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "DD";
	all_right = KawigiEdit_RunTest(4, p0, false, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// The signature of a permutation is a string that is computed as follows: for each pair of consecutive elements of the permutation, write down the letter 'I' (increasing) if the second element is greater than the first one, otherwise write down the letter 'D' (decreasing).
// 
// 
// 
// For example, the signature of the permutation {3,1,2,7,4,6,5} is "DIIDID".
// 
// 
// 
// Your task is to reverse this computation: You are given a string signature containing the signature of a permutation.
// Find and return the lexicographically smallest permutation with the given signature.
// If no such permutation exists, return an empty vector <int> instead.
// 
// 
// DEFINITION
// Class:PermutationSignature
// Method:reconstruct
// Parameters:string
// Returns:vector <int>
// Method signature:vector <int> reconstruct(string signature)
// 
// 
// NOTES
// -For any positive integer N, a permutation of N elements is a sequence of length N that contains each of the integers 1 through N exactly once.
// -To compare two permutations A and B, find the smallest index i such that A[i] and B[i] differ. If A[i] < B[i], we say that A is lexicographically smaller than B, and vice versa.
// 
// 
// CONSTRAINTS
// -signature will contain between 1 and 50 characters, inclusive.
// -Each character in signature will be either 'I' or 'D'.
// 
// 
// EXAMPLES
// 
// 0)
// "IIIII"
// 
// Returns: {1, 2, 3, 4, 5, 6 }
// 
// 
// 
// 1)
// "DI"
// 
// Returns: {2, 1, 3 }
// 
// There are two permutations with this signature: {3,1,2} and {2,1,3}. You must return the lexicographically smaller one.
// 
// 2)
// "IIIID"
// 
// Returns: {1, 2, 3, 4, 6, 5 }
// 
// 
// 
// 3)
// "DIIDID"
// 
// Returns: {2, 1, 3, 5, 4, 7, 6 }
// 
// This is the signature from the problem statement. Note that the correct answer is not the permutation from the problem statement.
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

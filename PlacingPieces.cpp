#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define endl 		("\n")
#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define Pf		printf
#define	Sf		scanf

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

class PlacingPieces
{
public:
	int optimalPlacement(int L, vector <int> pieces);
};


int PlacingPieces::optimalPlacement (int L, vector <int> pieces) 
{
	sort(all(pieces));

	DEBUG(L);
	tr(it, pieces)
		write(*it);
	cout << endl;

	if(*min_element(all(pieces)) > L)
		return 0;
	int N = pieces.size();
	int ret = N;

	int cntMin[3111];

	forn(i, N) {
		CL(cntMin, -1);
		cntMin[0] = 0;

		forab(j, i+1, N-1) 	rep(len, 1001, 0) {
			int par = len - pieces[j];
			if(par >= 0 && cntMin[par] > -1) {
				if(cntMin[len] == -1)
					cntMin[len] = cntMin[par] + 1;
				else
					cntMin[len] = min(cntMin[len], cntMin[par] + 1);
			}
		}
		
		int sum = 0;
		forn(j, i-1)
			sum += pieces[j];

		forn(len, 1001)	if( cntMin[len] > -1 && len + sum <= L) {
			if(L - sum - len < pieces[i] * (i + cntMin[len] + 1)) {
				Pf("sum[0-%d] = %d, peice[%d] = %d, cntMin[%d] = %d\n", i-1, sum, i, pieces[i], len, cntMin[len] );
				ret = min(ret, i + cntMin[len] + 1);
			}
		}
	}
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	PlacingPieces *obj;
	int answer;
	obj = new PlacingPieces();
	clock_t startTime = clock();
	answer = obj->optimalPlacement(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 9;
	int t1[] = {1,8};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You have received a new puzzle as a gift.  It consists of a board and several pieces of various lengths.  Each piece has the same width as the board.  The goal of the game is to place the least number of pieces on the board such that no other unused piece can be added legally.  Pieces must not hang over the edge of the board or be twisted at an angle.  Each piece must be oriented so that its width is parallel to the width of the board.  Pieces must not overlap, but their edges may touch.  Keep in mind that distances between pieces or the distances between pieces and the edges of the board are not necessarily integer numbers.  See the examples for further clarification.  
// 
// You will be given an int L, the length of the board, and a vector <int> pieces containing the lengths of the pieces.  Create a method optimalPlacement that returns the number of pieces placed on the board that allows you to solve the puzzle. 
// 
// 
// DEFINITION
// Class:PlacingPieces
// Method:optimalPlacement
// Parameters:int, vector <int>
// Returns:int
// Method signature:int optimalPlacement(int L, vector <int> pieces)
// 
// 
// CONSTRAINTS
// -L will be between 1 and 1000, inclusive.
// -pieces will contain between 1 and 30 elements, inclusive.
// -Each element of pieces will be between 1 and 100, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 9
// {1, 8}
// 
// Returns: 1
// 
// 
// You can place both pieces on the board and leave no space on it.  However, there is a better solution as depicted below.  Place only the second piece on the board, and leave a little space between it and the left and right edges of the board, so that the first piece can't fit:
// 
// 
// 
// 1)
// 36
// {1, 1, 5, 5, 5}
// 
// Returns: 4
// 
// 
// If we place all three pieces with length 5 on the board, we will have no choice but to also place the smallest two pieces.  However, if you place only two of them and the two smallest pieces, you can leave spaces on the board that are smaller than the length of the remaining piece.
// 
// 
// 
// 2)
// 37
// {1, 1, 5, 5, 5}
// 
// Returns: 5
// 
// You cannot leave any piece out here.
// 
// 3)
// 18
// {2, 2, 2, 9, 9, 10}
// 
// Returns: 2
// 
// Sometimes it is better to not place the piece with the highest length.
// 
// 4)
// 1
// {2, 3, 4}
// 
// Returns: 0
// 
// No piece fits on this board.
// 
// 5)
// 703
// {73, 76, 90, 42, 84, 13, 57, 88, 80, 45, 80, 1, 78, 41, 73, 40, 97, 42}
// 
// Returns: 7
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

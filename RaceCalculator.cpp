#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	cl(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0)
	#define debug 
#else 
	#define debug(x)	cout << #x << " = " << x << "\n"
#endif

class RaceCalculator
{
public:
	int bestRace(vector <int> distances, vector <int> times);
};

int RaceCalculator::bestRace (vector <int> distances, vector <int> times) 
{
	int ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	RaceCalculator *obj;
	int answer;
	obj = new RaceCalculator();
	clock_t startTime = clock();
	answer = obj->bestRace(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	
	{
	// ----- test 0 -----
	int t0[] = {1600,3200,16000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {299,655,4020};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1600,2000,3200,3000,5000,9600};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {234,306,499,462,802,1629};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1000,2000,3000,4000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {160,330,510,750};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {1000,50000,10000,5000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {200,70010,2250,1080};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// If a runner races a distance D in time T, and later races a distance 2D, that runner will likely take more than 2T time to finish it.  An examination of how times change with distances for a given runner can lead to the following approximation for the time it will take that runner to finish a given distance.  Given two races with distances D1 and D2 (D1<D2) which a runner ran in times T1 and T2 (T1<T2) , respectively, the approximate time it will take a runner to run a distance D is given by:
// T1*e^(ln(T2/T1)*ln(D1/D)/ln(D1/D2)).
// 
// While it is clear which of a runner's races for a given distance is the best (the one that he or she ran the fastest), it isn't so clear what race is the best over all distances.  This equation can help give an objective measure of that, however.  If a runner has raced distances of D1...Dn, with corresponding times of T1...Tn, then any pair of two distances with their times will be able to approximate the rest of the times with the equation from above. Any other time will have a percent error from this approximation given by (actualTime-expectedTime)/expectedTime.  Take the highest percent error for a time over all possible approximations, and this is that race's 'badness'.  The race with the  lowest badness is considered the best race.
// 
// Create a class RaceCalculator with a method bestRace that takes a vector <int> distances and a vector <int> times and returns an int that is the index of the best race specified by the input.  Each value in distances will correspond to the value in times of the same index.  All distances are in meters and all times are in seconds.
// 
// DEFINITION
// Class:RaceCalculator
// Method:bestRace
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int bestRace(vector <int> distances, vector <int> times)
// 
// 
// NOTES
// -In C++ e^x can be done with exp(x), and the natural log, ln(x), can be done with log(x), both functions are in math.h.
// -In C# e^x can be done with Math.Exp(x), and the natural log, ln(x), can be done with Math.Log(x).  The Math class is in the System namespace.
// -In Java e^x can be done with Math.exp(x), and the natural log, ln(x), can be done with Math.log(x).
// -In Visual Basic e^x can be done with Exp(x), and the natural log, ln(x), can be done with Log(x), both functions are in the System.Math namespace.
// 
// 
// CONSTRAINTS
// -distances and times will both contain between 3 and 50 elements, inclusive.
// -distances and times will contain the same number of elements.
// -Every element in distances and times will be between 1 and 100000, inclusive.
// -No value in distances will occur more than once.
// -If the i-th value in distances is less than the j-th value in distances, then the i-th value of times will be less than the j-th value of times.
// -To avoid rounding issues, no two races' badnesses will be within 1e-9 of each other.
// -To make the approximation reliable, all speeds (distance/time), including those generated by the approximation, will be between 0.1 meter/second and 100 meters/second, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {1600,3200,16000}
// {299,655,4020}
// 
// Returns: 2
// 
// This person runs 1.6 km in 4:59, 3.2 km in 10:55, and 16 km in 1:07:00.  The expected times for each distance (always using the approximation based on the results of the other two races) are about 4:59.8 for the 1.6 km, 10:53.7 for the 3.2 km, and 1:07:26.0 for the 16 km.  This results in badnesses of roughly -0.002767 for the 1.6 km, 0.001939 for the 3.2 km, and -0.006414 for the 16 km.
// 
// 1)
// {1600,2000,3200,3000,5000,9600}
// {234,306,499,462,802,1629}
// 
// Returns: 3
// 
// Steve Prefontaine was probably the best American runner of all time.  Here are his times for the 1.6 km, 2 km, 3 km, 3.2 km, 5 km, and 9.6 km.  The badnesses of the respective races are about:
// {0.0727,0.0747,0.0115,0.003,0.033,0.081}
// 
// 2)
// {1000,2000,3000,4000}
// {160,330,510,750}
// 
// Returns: 2
// 
// 3)
// {1000,50000,10000,5000}
// {200,70010,2250,1080}
// 
// Returns: 2
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define	forn(i, n)	for(int i = 0; i < n; i++)
#define	forab(i, a, b)	for(int i = a; i <= b; i++)
#define	rep(i, a, b)	for(int i = a; i>=b; i--)

int par[2600];

int FindSet(int x) {
	return x == par[x] ? x : par[x] = FindSet(par[x]);
}

void MergeSet(int a, int b) {
	int aa = FindSet(a), bb = FindSet(b);
	if(aa < bb)
		par[bb] = aa;
	else 
		par[aa] = bb;
}

class RectangleArea
{
public:
	int minimumQueries(vector <string> known)
	{
		forn(i, 2600)	par[i] = i;
		int n = known.size(), m = known[0].length();
		
		forn(i, n)	forn(j, m)	if( !(known[i][j]^'Y') )
			MergeSet(i, j+n);
		
		forn(i, m+n)
			cout << i << " : " << FindSet(i) << " \t ";
		cout << endl;

		int cnt = 0;
		forn(i, m+n)	if(par[i] == i)
			cnt++;
		return cnt-1;

		
		return -1;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	RectangleArea *obj;
	int answer;
	obj = new RectangleArea();
	clock_t startTime = clock();
	answer = obj->minimumQueries(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"NN","NN"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"YNY","NYN","YNY"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"YY","YY","YY","YY"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"NNNNNNNNNN"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 10;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"NNYYYNN","NNNNNYN","YYNNNNY","NNNYNNN","YYNNNNY"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Your friend has drawn a rectangle on the coordinate plane consisting of points (x, y) such that 0 <= x <= W, 0 <= y <= H, where W and H are positive numbers (not necessarily integer). Then she has divided it into a grid of NxM smaller rectangles. In order to do it, she has chosen numbers (X[0], X[1], ..., X[N]) and (Y[0], Y[1], ..., Y[M]) such that 0 = X[0] < X[1] < ... < X[N] = W and 0 = Y[0] < Y[1] < ... < Y[M] = H. The small rectangle in row i, column j of the grid consists of points (x, y) such that Y[i] <= y <= Y[i+1] and X[j] <= x <= X[j+1]. Note that rows are numbered from 0 to M-1 and columns are numbered from 0 to N-1.
// 
// Now, you and your friend play the following game. Initially, you only know the values of N and M, but do not know the values of W, H, X and Y. Your goal is to determine the area of the initial large rectangle, i.e., W * H, but since you don't know W and H, it's not so easy to do. In order to achieve the goal, you can ask questions to your friend. Each question is of the form: "What is the area of the small rectangle in row i, column j?" Your friend always gives true answers, i.e., she responds with the value of (Y[i+1] - Y[i]) * (X[j+1] - X[j]).
// 
// You have already asked some questions, the information about them is contained in a vector <string> known. It contains M elements, each element consists of N characters. The j-th character in i-th element is 'Y' if you already know the area of the small rectangle in row i, column j, and it is 'N' if you haven't yet asked the question about this small rectangle.
// 
// Return the minimum number of additional questions that you need to ask in order to determine the area of the initial large rectangle. If you can determine the area without asking additional questions, return 0.
// 
// DEFINITION
// Class:RectangleArea
// Method:minimumQueries
// Parameters:vector <string>
// Returns:int
// Method signature:int minimumQueries(vector <string> known)
// 
// 
// NOTES
// -Your goal is always achievable. For example, if you know the areas of all small rectangles, you can find the area of the large rectangle as the sum of areas of all small rectangles.
// 
// 
// CONSTRAINTS
// -known will contain between 1 and 50 elements, inclusive.
// -Each element of known will contain between 1 and 50 characters, inclusive.
// -All elements of known will contain the same number of characters.
// -Each character in known will be 'Y' or 'N'.
// 
// 
// EXAMPLES
// 
// 0)
// {"NN",
//  "NN"}
// 
// Returns: 3
// 
// Suppose that heights of rows 0 and 1 are R0 and R1 and widths of columns 0 and 1 are C0 and C1.
// You can ask 3 questions about rectangle at row 0, column 0 (suppose the answer is A00), at row 0, column 1 (answer is A01) and at row 1, column 0 (answer is A10). We then have the following equations:
// 
// R0 * C0 = A00
// R0 * C1 = A01
// R1 * C0 = A10
// 
// After several transformations:
// 
// C0 = A00 / R0
// C1 = A01 / R0
// R1 = A10 / C0 = A10 / (A00 / R0) = (A10 / A00) * R0
// 
// The total area can then be calculated as follows:
// 
// W * H = (R0 + R1) * (C0 + C1) = 
// = (R0 + (A10 / A00) * R0) * (A00 / R0 + A01 / R0) =
// = R0 * (1 + A10 / A00) * (1 / R0) * (A00 + A01) =
// = (1 + A10 / A00) * (A00 + A01)
// 
// So, 3 questions are enough to find the area of the large rectangle. It is impossible to achieve this goal with less than 3 questions.
// 
// 1)
// {"YNY",
//  "NYN",
//  "YNY"}
// 
// Returns: 1
// 
// Knowing the contents of any single additional small rectangle is enough to find the area of the large rectangle.
// 
// 2)
// {"YY",
//  "YY",
//  "YY",
//  "YY"}
// 
// Returns: 0
// 
// You already know everything in this test case, so no additional questions are needed.
// 
// 3)
// {"NNNNNNNNNN"}
// 
// Returns: 10
// 
// Here you need to ask questions about all small rectangles.
// 
// 4)
// {"NNYYYNN",
//  "NNNNNYN",
//  "YYNNNNY",
//  "NNNYNNN",
//  "YYNNNNY"}
// 
// Returns: 2
// 
// 
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class RepeatedPatterns
{
public:
	long long findZeroSegment(string P1, string P2, string zeroCount);
};

int calLen(string st, int b, int e, int add) {
	int ret = 0;
	for(int i = b; i != e && st[i] == '0'; i+=add, ret++)
		;
	return ret;
}	

long long RepeatedPatterns::findZeroSegment (string P1, string P2, string zeroCount) 
{
	SS ss(zeroCount);
	int64 n, e6 = 1e6;
	ss >> n;

	int64 sp1 = 0, lp1 = 0, sp2 = 0, lp2 = 0;
	sp1 = calLen(P1, 0, P1.size(), 1);
	sp2 = calLen(P2, 0, P2.size(), 1);
	lp1 = calLen(P1, P1.size()-1, -1, -1);
	lp2 = calLen(P2, P2.size()-1, -1, -1);
	DEBUG(P1);
	DEBUG(sp1);
	DEBUG(lp1);

	DEBUG(P2);
	DEBUG(sp2);
	DEBUG(lp2);
	
	if(sp1 == P1.size() && sp2 == P2.size())
		return 0;

	if(sp1 >= n)
		return 0;

	forn(i, P1.size()) {
		int len = 0;
		for(int j = i; j < P1.size() && P1[j] == '0'; j++)
			len++;
		if(len >= n)
			return i;
	}

	if(lp1 == P1.size() && e6 * P1.size() >= n)
		return 0ll;

	if(lp1 + sp1 >= n)
		return P1.size() - lp1;

	if(lp1 + sp2 >= n)
		return e6*P1.size() - lp1;

	forn(i, P2.size()) {
		int len = 0;
		for(int j = i; j < P2.size() && P2[j] == '0'; j++)
			len++;
		if(len >= n)
			return e6*P1.size() + i;
	}
	if(lp2 + sp1 >= n)
		return e6 * P1.size() + P2.size() - lp2;
	if(sp1 == P1.size() && lp2 + e6*P1.size() >= n )
		return e6*P1.size() + P2.size() - lp2;

	if(sp2 + lp2 >= n)
		return 2*e6*P1.size() + P2.size() + P2.size() - lp2;

	if(sp2 == P2.size()) {
		int64 k = ceil( (n - sp1 - lp1)/sp2);
		int64 idx = k * e6*P1.size() + (k*(k-1)/2)*P2.size() - lp1;

		if(k*P1.size() >= e6*e6/100)
			idx = -1;
		else if(k > e6*200)
			idx= -1;
		else if(idx >= e6*e6/100*e6 )
			idx = -1;
		else if(idx + n -1 >= e6*e6/100*e6 )
			idx = -1;
		DEBUG(k);
		DEBUG(idx);
		return idx;

	}

	

	return -1ll;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, string p1, string p2, bool hasAnswer, long long p3) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"" << "," << "\"" << p2 << "\"";
	cout << "]" << endl;
	RepeatedPatterns *obj;
	long long answer;
	obj = new RepeatedPatterns();
	clock_t startTime = clock();
	answer = obj->findZeroSegment(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	string p1;
	string p2;
	long long p3;
	
	{
	// ----- test 0 -----
	p0 = "111010100001010";
	p1 = "010000001000";
	p2 = "3";
	p3 = 7ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "1101010010";
	p1 = "0001000";
	p2 = "3";
	p3 = 9999999ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "1101010010";
	p1 = "0001000";
	p2 = "5";
	p3 = 20000011ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "10101010";
	p1 = "101010101010";
	p2 = "9876543219876";
	p3 = -1ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "11111111111111111111111111";
	p1 = "0";
	p2 = "9876543219876";
	p3 = -1ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "1";
	p1 = "0";
	p2 = "140424892";
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, false, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Given are two strings P1 and P2. Each of these strings contains a pattern of zeros and ones.
// 
// 
// 
// The string S(n) is formed by concatenating 1,000,000 copies of P1 followed by n copies of P2.
// 
// 
// 
// The infinite string S is formed by concatenating the strings S(1), S(2), S(3), ... in this order.
// 
// 
// 
// The string T consists of the first 10^16 characters of the string S.
// 
// 
// 
// We are interested in substrings of T that are zeroCount characters long and contain only zeros.
// Write a method that finds the first occurrence of such a substring in T, and returns the zero-based index of 
// its first character. In case T contains no such substring return -1.
// 
// 
// DEFINITION
// Class:RepeatedPatterns
// Method:findZeroSegment
// Parameters:string, string, string
// Returns:long long
// Method signature:long long findZeroSegment(string P1, string P2, string zeroCount)
// 
// 
// NOTES
// -The number zeroCount may be large, and therefore it is specified as a string.
// 
// 
// CONSTRAINTS
// -P1 will contain between 1 and 50 characters, inclusive.
// -P2 will contain between 1 and 50 characters, inclusive.
// -P1 and P2 will contain only zeroes ('0') and ones ('1').
// -zeroCount will contain between 1 and 17 characters, inclusive.
// -zeroCount will contain only digits ('0'-'9').
// -zeroCount will represent a positive integer between 1 and 10^16, inclusive.
// -zeroCount will not contain leading zeros.
// 
// 
// EXAMPLES
// 
// 0)
// "111010100001010"
// "010000001000"
// "3"
// 
// Returns: 7
// 
// The first occurrence of three consecutive zeroes is right in the first copy of P1.
// 
// 1)
// "1101010010"
// "0001000"
// "3"
// 
// Returns: 9999999
// 
// This time the first substring "000" starts with the last character of the 1,000,000th copy of P1.
// 
// 2)
// "1101010010"
// "0001000"
// "5"
// 
// Returns: 20000011
// 
// We have the same string T as in Example 1, only we look for the substring "00000". The first occurrence is between the second and the third copy of P2.
// 
// 3)
// "10101010"
// "101010101010"
// "9876543219876"
// 
// Returns: -1
// 
// Nowhere in the infinite string S can we find two consecutive zeroes.
// Clearly, in the string T there is no substring with 9876543219876 consecutive zeroes.
// 
// 4)
// "11111111111111111111111111"
// "0"
// "9876543219876"
// 
// Returns: -1
// 
// The infinite string S does contain 9876543219876 consecutive zeroes. However, the first occurrence is too far, thus the string T doesn't contain it.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef string ST;
typedef stringstream SS;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define	PI	3.141592653589793
#define	E	2.718281828459045

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define	forn(i, n)	for(int i = 0; i < n; i++)
#define	forab(i, a, b)	for(int i = a; i <= b; i++)
#define	rep(i, a, b)	for(int i = a; i>=b; i--)
#define vd vector<double>

class ResistorCombinations
{
	double ret, target;
	vector<double> tmp;

	void Process(vector <double> v)
	{
		int sz = v.size();

		if(sz == 0)	return;

		if(sz == 1)
		{
			tmp.pb(v[0]);
//			cout << v[0] << endl;
			if( abs(ret - target) > abs(v[0] - target) )
				ret = v[0];
			return;
		}


		forn(i, sz)	forn(j, i)
		{
			vector <double> R;
			double Rp = v[i]*v[j] / (v[i] + v[j]), Rs = v[i] + v[j];
			
			forn(k, sz)	if(k != i && k != j)	R.pb(v[k]);

			R.pb(Rp);	Process(R);	R.pop_back();
			R.pb(Rs);	Process(R);	R.pop_back();
//			R.pb(v[i]);	Process(R);	R.pop_back();
//			R.pb(v[j]);	Process(R);

//			Process(R);
		}
	}

public:
	double closestValue(vector <string> resistances, double _target)
	{
		vector<double> v;
		target = _target;

		tr(it, resistances)	v.pb(atof(it->c_str()));

		tr(it, v)	cout << *it << endl;

		ret = accumulate(all(v), 0.0);
// /*
		int sz = v.size();

		forn(i, (1 << sz))
		{
			vector <double> R;
			forn(j, sz)	if(i & (1 << j))	R.pb(v[j]);
			Process(R);
		}
// */
//		Process(v);

		cout << SZ(tmp) << " -> " << (unique(all(tmp)) - tmp.begin()) << endl;
		
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, double p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	ResistorCombinations *obj;
	double answer;
	obj = new ResistorCombinations();
	clock_t startTime = clock();
	answer = obj->closestValue(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	double p1;
	double p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"2","3","5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2.5;
	p2 = 2.5;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"2","3","5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 0.967741935483871;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"10.25","13.31","6.777","12.2"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 10.5;
	p2 = 10.510805181371511;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"10000","2000","300","40","5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 20000;
	p2 = 12345.0;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"125.10000","00270.9","000625.55","90.100000","0015.60000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 153;
	p2 = 152.75975812465552;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are an electrical engineer putting together a prototype circuit in the lab.  You need to add in one resistor to finish things up, but there is a problem: you need a resistor with a very exact value, and resistors are generally only guaranteed to be within 5% or 10% of the value they claim to be.  You have a few resistors whose values you have measured, and you want to know how closely you can approximate the resistance you need by combining those resistors in different ways.
// 
// Every resistor has a resistance, which is measured in ohms.  Multiple resistors can be added together to create a new resistor with its own resistance.  Resistors can be added in series or in parallel, each way resulting in a different equivalent resistance.
// 
// Consider two resistors with resistances R1 and R2.  When added in series the equivalent resistance, Req, is the sum of the resistances, so Req=R1+R2.  When added in parallel, the equivalent is given by Req=1/(1/R1+1/R2)=R1R2/(R1+R2).  Combining more than two resistors with the same operation (parallel or series) is the same as combining two of the resistors, then combining the result with a third resistor, then combining the result of that with another resistor, etc.
// 
// As an example, consider three resistors, with resistances of 2, 3, and 5 ohms.  The 2 ohm and 3 ohm resistors can be added in series to create another 5 ohm resistor.  Those two 5 ohm resistors could be added in series  to create a 10 ohm resistor, or in  parallel to create a 2.5 ohm resistor.  You could also add all three original resistors together in parallel, in that case your new resistance would be Req=1/(1/2+1/3+1/5)=30/31.
// 
// By combining resistors in different combinations, you can get many different equivalent resistances.  Given a vector <string>, resistances, which represents the resistances of all of the resistors you have, and a double, target, return a double which is the closest resistance to target that can be made with the values in resistances.
// 
// DEFINITION
// Class:ResistorCombinations
// Method:closestValue
// Parameters:vector <string>, double
// Returns:double
// Method signature:double closestValue(vector <string> resistances, double target)
// 
// 
// NOTES
// -Adding resistors in series and in parallel are not the only ways to combine resistors, but they are the only ways that should be considered for this problem.
// -Your return value must have relative or absolute error of less than 1e-9.
// -Every combination of resistors must be made of one or more resistors.
// 
// 
// CONSTRAINTS
// -resistances will contain between 1 and 5 elements, inclusive.
// -Each element of resistances will be a value greater than 1e-3 and less than 1000000.
// -Each element of resistances will contain only digits ('0'-'9') and at most one decimal point.
// -target will be a positive value less than 1000000.
// -To avoid rounding errors, there will be no two possible resistances that can be made such that one is less than target and one is greater than target and both are within 1e-3 of being the closest value to target.
// 
// 
// EXAMPLES
// 
// 0)
// {"2","3","5"}
// 2.5
// 
// Returns: 2.5
// 
// The example from above.  The target value can be exactly reached by adding the 2 and 3 ohm resistors in series to make another 5 ohm resistor, and then adding that in parallel with the original 5 ohm resistor to get a 2.5 ohm resistor.
// 
// 1)
// {"2","3","5"}
// 1
// 
// Returns: 0.967741935483871
// 
// The closest value in this case comes from adding all the resistors in parallel: 1/R=1/2+1/3+1/5, R=30/31.
// 
// 2)
// {"10.25","13.31","6.777","12.2"}
// 10.5
// 
// Returns: 10.510805181371511
// 
// In this case the best value comes from adding resistors 0 and 1 in series, resistors 2 and 3 in series, and then adding both of those in parallel.
// 
// 3)
// {"10000","2000","300","40","5"}
// 20000
// 
// Returns: 12345.0
// 
// 4)
// {"125.10000","00270.9","000625.55","90.100000","0015.60000"}
// 153
// 
// Returns: 152.75975812465552
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

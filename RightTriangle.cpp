#include <bits/stdc++.h>
using namespace std;

class RightTriangle
{
public:
	long long triangleCount(int places, int points, int a, int b, int c);
};

long long RightTriangle::triangleCount (int places, int points, int a, int b, int c) 
{
	long long ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, int p4, bool hasAnswer, long long p5) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4;
	cout << "]" << endl;
	RightTriangle *obj;
	long long answer;
	obj = new RightTriangle();
	clock_t startTime = clock();
	answer = obj->triangleCount(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p5 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p5;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	long long p5;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 9;
	p1 = 3;
	p2 = 0;
	p3 = 3;
	p4 = 0;
	p5 = 0ll;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 40;
	p1 = 3;
	p2 = 5;
	p3 = 0;
	p4 = 0;
	p5 = 1ll;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 4;
	p1 = 4;
	p2 = 16;
	p3 = 24;
	p4 = 17;
	p5 = 4ll;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 1000000;
	p1 = 47000;
	p2 = 0;
	p3 = 2;
	p4 = 5;
	p5 = 0ll;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 200000;
	p1 = 700;
	p2 = 123456;
	p3 = 789012;
	p4 = 345678;
	p5 = 6980ll;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Consider a circle in the plane.
// 
// 
// You are given an int places. This is the number of places that are equally spaced along the perimeter of the circle, i.e., the distance between any two consecutive places is equal.
// The places are numbered 0 to places-1 in clockwise order, starting at an arbitrary place.
// 
// 
// We will now draw red points in some of the places. The number of red points is given as an int points. As the number of points may be large, we will generate them using a simple process that is described below.
// 
// 
// Finally, once all points are generated, your task is to find and return the number of right triangles that have all three vertices in red points.
// 
// 
// To generate the points, you are given three ints a, b, and c.
// For n = 0, 1, 2, 3, ..., points-1, execute the following steps:
// 
// 
// Compute P[n] = (a*n*n + b*n + c) modulo places.
// Starting at P[n], find the first place in the clockwise direction that does not contain a red point.
// Put a red point onto that place.
// 
// 
// DEFINITION
// Class:RightTriangle
// Method:triangleCount
// Parameters:int, int, int, int, int
// Returns:long long
// Method signature:long long triangleCount(int places, int points, int a, int b, int c)
// 
// 
// NOTES
// -A right triangle is a triangle with non-zero area in which one of the angles is exactly 90 degrees.
// -For any valid input the answer fits into a long long (i.e., a signed 64-bit integer variable).
// 
// 
// CONSTRAINTS
// -places will be between 1 and 1,000,000, inclusive.
// -points will be between 0 and 100,000, inclusive.
// -points will not be greater than places.
// -a will be between 0 and 1,000,000, inclusive.
// -b will be between 0 and 1,000,000, inclusive.
// -c will be between 0 and 1,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 9
// 3
// 0
// 3
// 0
// 
// Returns: 0
// 
// The points are placed on places 0, 3, and 6. The resulting triangle is not a right triangle (in fact, it is equilateral).
// 
// 1)
// 40
// 3
// 5
// 0
// 0
// 
// Returns: 1
// 
// This time the red points are on places 0, 5, and 20. The only triangle determined by these points is a right triangle.
// 
// 2)
// 4
// 4
// 16
// 24
// 17
// 
// Returns: 4
// 
// This time the formula for the next place always gives the output 1. Hence the points are placed on places 1, 2, 3, and 0, in this order. Each of the four triangles determined by these points is a right triangle.
// 
// 3)
// 1000000
// 47000
// 0
// 2
// 5
// 
// Returns: 0
// 
// An awful lot of obtuse triangles.
// 
// 4)
// 200000
// 700
// 123456
// 789012
// 345678
// 
// Returns: 6980
// 
// Watch out for integer overflow when computing P[n].
// 
// END KAWIGIEDIT TESTING

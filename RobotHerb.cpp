#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define endl 		("\n")

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define Pf		printf
#define	Sf		scanf

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

// /*
#ifdef DEBUG
	#undef DEBUG
#endif
#define DEBUG
// */

class RobotHerb
{
public:
	long long getdist(int T, vector <int> a);
};

int Y[] = {1, 0, -1, 0};
int X[] = {0, 1, 0, -1};

void displace(int64 &x, int64 &y, int64 &dir, const vi &a) {
//	x = 0, y = 0, dir = 0;
	forn(i, a.size()) {
		x += 1ll*a[i]*X[dir] ;
		y += 1ll*a[i]*Y[dir] ;
		dir = (dir + a[i]) % 4;
		dir = (dir + 4) % 4;
	}
}

long long RobotHerb::getdist (int T, vector <int> a) 
{
	int64 xdisp, ydisp, dir;
	xdisp = ydisp = dir = 0;

	forn(i, 4)
		displace(xdisp, ydisp, dir, a);
	DEBUG(xdisp);
	DEBUG(ydisp);
	DEBUG(dir);
	int64 xans = (T/4) * xdisp;
	int64 yans = (T/4) * ydisp;

	xdisp = 0, ydisp = 0, dir = 0;
	forn(i, T%4) {
		displace(xdisp, ydisp, dir, a);
	}
	xans += xdisp;
	yans += ydisp;

	DEBUG(xans);
	DEBUG(yans);
	return abs(xans) + abs(yans);

}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, long long p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	RobotHerb *obj;
	long long answer;
	obj = new RobotHerb();
	clock_t startTime = clock();
	answer = obj->getdist(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	long long p2;
	
	{
	// ----- test 0 -----
	p0 = 1;
	int t1[] = {1,2,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 100;
	int t1[] = {1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 5;
	int t1[] = {1,1,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 10ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 1000000000;
	int t1[] = {100};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 100000000000ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 570;
	int t1[] = {2013,2,13,314,271,1414,1732};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4112ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 1000000000;
	int t1[] = {10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000,10000000};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(5, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = 999999999;
	int t1[] = {9999984,9999988,9999980,9999916,9999996,9999936,9999988,9999992,9999952,9999924,9999964,9999928,9999992,9999960,9999964,9999928,9999940,9999928,9999972,9999936,9999912,9999968,9999968,9999932,9999984,9999932,9999964,9999924,9999968,9999936,9999932,9999904,9999924,9999960,9999972,9999968,9999996,9999956,9999912,9999944,9999932,9999976,9999924,9999920,9999984,9999940,10000000,9999924,9999916,9999972};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(6, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Robot Herb is playing on an infinite square grid.
// At any moment, Herb stands on one of the squares and he faces one of the four cardinal directions.
// In his memory, Herb has a program.
// The program is a sequence of commands.
// For each i, the i-th of these commands has the following form:
// 
// First move forward a[i] tiles.
// Then turn 90 degrees to the right, a[i] times in a row.
// 
// Herb has decided to run the program T times.
// You are given the int T and the vector <int> a that describes Herb's program.
// Let A be the initial position of Herb and B be his position after the program was executed T times. Return the Manhattan distance between tiles A and B.
// 
// DEFINITION
// Class:RobotHerb
// Method:getdist
// Parameters:int, vector <int>
// Returns:long long
// Method signature:long long getdist(int T, vector <int> a)
// 
// 
// NOTES
// -Let's introduce a Cartesian coordinate system on the grid so that each cardinal direction is parallel to one of the axes. The Manhattan distance between two tiles with centers at points (x1, y1) and (x2, y2) is defined as |x1-x2| + |y1-y2|.
// 
// 
// CONSTRAINTS
// -T will be between 1 and 1,000,000,000, inclusive.
// -a will contain between 1 and 50 elements, inclusive.
// -Each element of a will be between 1 and 10,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 1
// {1,2,3}
// 
// Returns: 2
// 
// Suppose that initially Herb stands on the tile with center at (0, 0) and faces the positive y direction. The program will get executed as follows:
// 
//                        tile         direction
// After 1st command:     (0, 1)       positive x
// After 2nd command:     (2, 1)       negative x
// After 3rd command:     (-1, 1)      negative y
// 
// The manhattan distance between the initial and the final positions is |-1| + |1| = 2.
// 
// 1)
// 100
// {1}
// 
// Returns: 0
// 
// 
// 
// 2)
// 5
// {1,1,2}
// 
// Returns: 10
// 
// 
// 
// 3)
// 1000000000
// {100}
// 
// Returns: 100000000000
// 
// The answer doesn't fit into a 32-bit integer data type.
// 
// 4)
// 570
// {2013,2,13,314,271,1414,1732}
// 
// Returns: 4112
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

class RockSkipping
{
public:
	double probability(string pads, int maxDist);
};


double RockSkipping::probability (string pads, int maxDist) 
{
	double ret = 0;
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, int p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << p1;
	cout << "]" << endl;
	RockSkipping *obj;
	double answer;
	obj = new RockSkipping();
	clock_t startTime = clock();
	answer = obj->probability(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	double p2;
	
	{
	// ----- test 0 -----
	p0 = ".";
	p1 = 100;
	p2 = 100.0;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "...X";
	p1 = 2;
	p2 = 50.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "........................X";
	p1 = 50;
	p2 = 11.60725450562586;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "...X......XXXX...XX.X..X...XX...";
	p1 = 48;
	p2 = 5.408479511004734E-8;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are skipping rocks on a lake.  To skip a rock, you throw the rock horizontally with its flattest edge down and parallel to the lake, and spin it as it leaves your hand.  The rock will skim the surface of the water, and leap back into the air for a distance, then skim again, repeating until it enters the water.  The spin on the rock keeps it flat while it flies through the air, and its direction stays relatively constant.  The pattern the rock takes as it skips along the lake is quite unusual, due to the imperfect surfaces of the rock and lake.  The rock's skips (distances the rock jumps) are on average smaller as the rock gets further away, probably due to resistance against the water and air.  However, sometimes the rock will go further than previous skips.  Also, when the rock hits one of the many lily pads on the lake, it immediately sinks after sliding over the lily pad.  Interestingly enough, the number of times the rock skips appears to be somewhat constant (unless it hits a lily pad).
// 
// 
// 
// Being the geeky computer scientist that you are, you devise a function determining the probablity that a rock being skipped will avoid all the lily pads.  There are two inputs for your function, the lily pad pattern (pads) on the lake in the direction you are throwing, and the maximum distance (maxDist) that the rock will skip after striking the water for the first time.
// 
// 
// 
// pads will be input as a string.  Each character in the string will represent a space of lake, '.' representing open water and 'X' representing a lily pad.  Assume the lake continues infinitely off to the right of the pattern, repeating the pattern over and over again.  So for instance, the pattern ".X.X.." corresponds to the lake .X.X...X.X...X.X.., which extends infinitely to the right.  You throw your rock from the left side of the lake across to the right side, and aim it so the rock strikes the first space of lake (the first character in pads, which is always guaranteed to be open water).  You should also assume that the rock's horizontal direction does not change (i.e. the rock's horizontal movement is always along the lily pad pattern).
// 
// 
// 
// maxDist will define how hard you throw the rock.  You hypothesize that for the first skip, the maximum distance it could possibly jump is maxDist lake spaces.  After each skip, the maximum distance is decreased by one, yielding a maximum distance of maxDist - N spaces for skip N (N starts at 0).  The rock succumbs to the icy water when N equals maxDist or when the rock hits a lily pad.  To account for the erratic skipping patterns, you hypothesize that the rock has an equal chance of skipping any integral distance between 1 and maxDist - N inclusive for skip N (to simplify the problem, assume the rock always lands in the middle of a space).
// 
// 
// 
// Your return value should be a probability from 0 to 100, which represents the percentage likelihood that the rock will not hit any lily pads.
// 
// 
// DEFINITION
// Class:RockSkipping
// Method:probability
// Parameters:string, int
// Returns:double
// Method signature:double probability(string pads, int maxDist)
// 
// 
// NOTES
// -Your return value must be within 1e-9 absolute or relative of the actual value.
// -Remember, the rock can only skip integral distances.
// 
// 
// CONSTRAINTS
// -pads will have between 1 and 50 characters, inclusive.
// -pads will consist only of the characters '.' and 'X'.
// -The first character in pads will be a '.'
// -maxDist will be between 2 and 100, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "."
// 100
// 
// Returns: 100.0
// 
// No lily pads to hit, and therefore, a 0% chance of hitting them.
// 
// 1)
// "...X"
// 2
// 
// Returns: 50.0
// 
// The rock's first destination is always the first space.  It has a 50% chance of skipping to the second space, and a 50% chance of skipping to the third space.  For the second skip, the maximum distance is 1, which means it has a 100% chance of moving ahead one space.  The 50% chance that skipped to the second space now skips to the third space, and gracefully sinks.  The 50% chance that skipped to the third space now skips to the fourth space and lands on the pad.  Therefore, the rock has a 50% chance of surviving the pads.
// 
// 2)
// "........................X"
// 50
// 
// Returns: 11.60725450562586
// 
// Even with the lily pads only covering 4% of the lake, about 88% of your rocks will eventually hit them.
// 
// 3)
// "...X......XXXX...XX.X..X...XX..."
// 48
// 
// Returns: 5.408479511004734E-8
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

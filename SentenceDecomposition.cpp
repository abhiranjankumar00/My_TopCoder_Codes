#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class SentenceDecomposition
{
public:
	int decompose(string sentence, vector <string> validWords);
};

vs validWords;
string sentence;

const int inf = 55;

int dp[55];

bool isSimilar(string st1, string st2) {
	sort(all(st1));
	sort(all(st2));
	return st1 == st2;
}

int match(string st) {
	int ret = inf;

	tr(it, validWords) {
		if(isSimilar(st, *it)) {
			assert(st.size() == it->size());
			int cost = 0;
			forn(i, st.size())
				if(st[i] != it->at(i))
					cost++;
			ret = min(ret, cost);
		}
	}
	return ret;
}

int solve(int idx = sentence.size()-1) {
	int &ret = dp[idx];
	
	if(ret > -1)
		return ret;

	ret = inf;

	forn(i, idx) {
		int tmp1 = solve(i);
		int tmp2 = match(sentence.substr(i+1, idx-i));
		ret = min(ret, tmp1+tmp2);
	}

	return ret;
}

int SentenceDecomposition::decompose (string sentence, vector <string> validWords) 
{
	::sentence = " " + sentence;
	::validWords = validWords;
	CL(dp, -1);
	dp[0] = 0;
	return solve() == inf ? -1 : solve();
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, vector <string> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SentenceDecomposition *obj;
	int answer;
	obj = new SentenceDecomposition();
	clock_t startTime = clock();
	answer = obj->decompose(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <string> p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = "neotowheret";
	string t1[] = {"one","two","three","there"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 8;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "abba";
	string t1[] = {"ab","ac","ad"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "thisismeaningless";
	string t1[] = {"this","is","meaningful"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = -1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "ommwreehisymkiml";
	string t1[] = {"we","were","here","my","is","mom","here","si","milk","where","si"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 10;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "ogodtsneeencs";
	string t1[] = {"go","good","do","sentences","tense","scen"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 8;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "sepawaterords";
	string t1[] = {"separate","words"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = -1;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Little Bonnie and her friends were dismayed to learn that their parents were reading all of their private communications.  They decided to invent a new language that would allow them to talk freely.  What they finally came up with was a language where sentences are built using a special method. 
// 
// 
// All the valid words that can be used in the new language are given in the vector <string> validWords.  A sentence is a concatenation (with no spaces) of a sequence of valid words.  Each valid word can appear 0 or more times in the sentence.  What makes the language special is that each word can be transformed by rearranging its letters before being used.  The cost to transform a word is defined as the number of character positions where the original word and the transformed word differ.  For example, "abc" can be transformed to "abc" with a cost of 0, to "acb", "cba" or "bac" with a cost of 2, and to "bca" or "cab" with a cost of 3. 
// 
// 
// Although several different sequences of valid words can produce the same sentence in this language, only the sequence with the least total transformation cost carries the meaning of the sentence.  The advantage of the new language is that the parents can no longer understand what the kids are saying.  The disadvantage is that the kids themselves also do not understand.  They need your help. 
// 
// 
// Given a string sentence, return the total cost of transformation of the sequence of valid words which carries the meaning of the sentence, or -1 if no such sequence exists.
// 
// DEFINITION
// Class:SentenceDecomposition
// Method:decompose
// Parameters:string, vector <string>
// Returns:int
// Method signature:int decompose(string sentence, vector <string> validWords)
// 
// 
// NOTES
// -If a word is used multiple times in a sentence, each occurrence can be transformed differently.
// 
// 
// CONSTRAINTS
// -sentence will contain between 1 and 50 lowercase letters ('a'-'z'), inclusive.
// -validWords will contain between 1 and 50 elements, inclusive.
// -Each element of validWords will contain between 1 and 50 lowercase letters ('a'-'z'), inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "neotowheret"
// {"one", "two", "three", "there"}
// 
// Returns: 8
// 
// The following transformations can be made:
// 
// "one" -> "neo" with a cost of 3 
// "two" -> "tow" with a cost of 2 
// "three" -> "heret" with a cost of 3 
// "there" -> "heret" with a cost of 5 
// 
// So the sequence {"one", "two", "three"} is the one carrying the meaning of "neotowheret". Its total transformation cost is 3 + 2 + 3 = 8.
// 
// 1)
// "abba"
// {"ab", "ac", "ad"}
// 
// Returns: 2
// 
// The word "ab" is used twice, and each time, it is transformed differently.
// 
// 2)
// "thisismeaningless"
// {"this", "is", "meaningful"}
// 
// Returns: -1
// 
// 
// 
// 3)
// "ommwreehisymkiml"
// {"we", "were", "here", "my", "is", "mom", "here", "si", "milk", "where", "si"}
// 
// Returns: 10
// 
// 
// 
// 4)
// "ogodtsneeencs"
// {"go", "good", "do", "sentences", "tense", "scen"}
// 
// Returns: 8
// 
// 
// 
// 5)
// "sepawaterords"
// {"separate","words"}
// 
// Returns: -1
// 
// You are only allowed to rearrange letters within words, and not in the entire sentence.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

#include <bits/stdc++.h>
using namespace std;

class SequenceOfCommands
{
public:
	string whatHappens(vector <string> commands);
};

int X[] = {1, 0, -1, 0};
int Y[] = {0, 1, 0, -1};

string SequenceOfCommands::whatHappens (vector <string> commands) 
{
  string steps = "";
  for(auto it = (commands).begin(); it != (commands).end(); ++it) {
    steps += *it;
  }
  int N = steps.size();

  int curX = 0, curY = 0, dir = 0;

  for(int i = 0; i < (int)N; ++i) {
    if(steps[i] == 'S') {
      curX += X[dir];
      curY += Y[dir];
    }
    else if(steps[i] == 'L')
      dir = (dir+1)%4;
    else 
      dir = (dir+3)%4;
  }

  if(dir == 0 && (curX != 0 || curY != 0))
    return "unbounded";
  return "bounded";

}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SequenceOfCommands *obj;
	string answer;
	obj = new SequenceOfCommands();
	clock_t startTime = clock();
	answer = obj->whatHappens(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	string p1;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"L"};
	p1 = "bounded";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"SRSL"};
	p1 = "unbounded";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"SSSS","R"};
	p1 = "bounded";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"SRSL","LLSSSSSSL","SSSSSS","L"};
	p1 = "unbounded";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are standing on some arbitrary point in the infinite plane.
// 
// 
// You are given a vector <string> commands that contains the commands you have to execute.
// Each character of each element of commands is one command.
// The commands must be executed in the given order: first you execute all commands in the first element of commands one by one, 
// then those in the second element, etc.
// 
// 
// There are only three types of commands: 'S' means "step forward", 'L' means "turn 90 degrees to the left", and 'R' means "turn 90 degrees to the right". All your steps have the same length.
// 
// 
// You will be executing the commands forever: after you execute the last character of the last element of commands, you will always start from the beginning again.
// 
// 
// We say that your path is bounded if there is some positive real number R such that while executing the infinite sequence of steps you will never leave the circle with radius R steps and center at your starting location.
// 
// 
// Given the vector <string> commands, your method should determine whether your path will be bounded or not. Return the string "bounded" (quotes for clarity) if the path is bounded and "unbounded" if it is not.
// 
// 
// DEFINITION
// Class:SequenceOfCommands
// Method:whatHappens
// Parameters:vector <string>
// Returns:string
// Method signature:string whatHappens(vector <string> commands)
// 
// 
// CONSTRAINTS
// -commands will contain between 1 and 50 elements, inclusive.
// -Each element in commands will contain between 1 and 50 characters, inclusive.
// -Each character in each element of commands will be one of 'S', 'L', and 'R'.
// 
// 
// EXAMPLES
// 
// 0)
// {"L"}
// 
// Returns: "bounded"
// 
// You are standing on the same spot forever, and in each step you take a turn 90 degrees to the left. This path is clearly bounded.
// 
// 1)
// {"SRSL"}
// 
// Returns: "unbounded"
// 
// 
// Imagine that you start executing the commands facing to the north. While following this sequence you will repeatedly execute the following steps: make a step to the north, rotate right, make a step to the east, and rotate left (to face north again).
// 
// 
// Given enough time, this path will take you arbitrarily far away from the spot where you started, hence it is unbounded.
// 
// 
// 2)
// {"SSSS","R"}
// 
// Returns: "bounded"
// 
// While executing this sequence of commands, you will be walking along the boundary of a small square.
// 
// 3)
// {"SRSL","LLSSSSSSL","SSSSSS","L"}
// 
// Returns: "unbounded"
// 
// 
// 
// END KAWIGIEDIT TESTING

#include <bits/stdc++.h>
using namespace std;

class StonesOnATree
{
	vector<int> p;
	vector<int> w;
	vector<int> memo;
	int N;
public:

	int parent(int nd) {
		return nd == 0 ? -1 : p[nd-1];
	}

	vector<int> getChildren(int nd) {
		vector<int> children;
		for(int i = 0; i < N; i++)
			if(parent(i) == nd)
				children.push_back(i);

		/*
		printf("Children[%d]: ", nd);
		for(auto ch: children)
			cout << ch << " ";
		cout << endl;
		*/

		return children;
	}

	int minWeight(int node) {
		if(memo[node] != -1)
			return memo[node];

		int ret = 0;
		vector<int> children = getChildren(node);

		// Leaf
		if(children.empty())
			ret = w[node];
		else {
			int curWt = w[node];
			for(auto ch: children)
				curWt += w[ch];

			vector<int> childrenWeights;
			for(auto ch: children)
				childrenWeights.push_back(minWeight(ch));

			for(auto chWt: childrenWeights)
				curWt = max(curWt, chWt);
			ret = curWt;
		}

		printf("minWeight[%d] = %d\n", node, ret);
		memo[node] = ret;
		return ret;
	}


    int minStones(vector <int> _p, vector <int> _w)
    {
		p = _p;
		w = _w;
		N = w.size();
		memo.resize(N, -1);

        int ret = minWeight(0);
        return ret;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	StonesOnATree *obj;
	int answer;
	obj = new StonesOnATree();
	clock_t startTime = clock();
	answer = obj->minStones(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {0,1,2,3};
	p1 = {1,2,2,4,4};
	p2 = 8;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {0,0};
	p1 = {1,2,3};
	p2 = 6;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {0};
	p1 = {100000,100000};
	p2 = 200000;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {0,0,1,1,2,2};
	p1 = {1,1,1,1,1,1,1};
	p2 = 4;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {0,0,1,2,3,4,4,2,1,3,6,7};
	p1 = {1,2,3,4,5,6,6,7,8,8,8,9,10};
	p2 = 22;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are given a rooted tree with n nodes.
// The nodes are labeled from 0 to n-1.
// Node 0 is the root.
// Each node of the tree has at most two children.
// 
// 
// 
// 
// You are given the description of the tree: the vector <int>s p and w.
// The vector <int> p has n-1 elements.
// For each valid i, node p[i] is the parent of node (i+1).
// You may assume that for each i we have p[i] ≤ i.
// The vector <int> w has n elements.
// For each valid i, w[i] is the weight of node i.
// 
// 
// 
// 
// 
// The vector <int> w has a special property: it is non-decreasing.
// That is, for each valid i we have w[i-1] ≤ w[i].
// 
// 
// 
// 
// 
// All nodes of the tree are currently empty.
// You are now going to play a game with the tree and an unlimited supply of stones.
// The game is played in turns.
// In each turn you can either remove a single stone from anywhere into a tree, or you can place a single stone onto a node of the tree.
// However, there is a restriction on placing the stones:
// you may only place a stone onto a node if all of its children currently have stones placed on them.
// (Note that this means that you can always place a stone onto any leaf of the tree.)
// 
// 
// 
// 
// 
// The weight of a given state of the game is equal to the sum of weights of nodes with stones.
// 
// 
// 
// 
// 
// You win the game by placing a stone onto the root of the tree.
// You want to win the game.
// If there are multiple ways to do so, you prefer a way for which the maximum weight of a state during the game is minimized.
// Compute and return this weight.
// In other words, compute and return the smallest W for which there is a way to win the game such that during the game the total weight of nodes with stones never exceeds W.
// 
// 
// DEFINITION
// Class:StonesOnATree
// Method:minStones
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int minStones(vector <int> p, vector <int> w)
// 
// 
// CONSTRAINTS
// -p will have between 1 and 999 elements, inclusive. (Thus, the number of nodes is between 2 and 1,000, inclusive.)
// -The i-th element of p will be between 0 and i, inclusive.
// -In the given tree each node will have at most two children. In other words, each value will appear in p at most twice.
// -w will have exactly len(p)+1 elements.
// -Each element of w will be 1 and 10^5, inclusive.
// -Elements of w will be non-decreasing.
// 
// 
// EXAMPLES
// 
// 0)
// {0,1,2,3}
// {1,2,2,4,4}
// 
// Returns: 8
// 
// There are five nodes in a line. 
// Here, one optimal solution is as follows:
// 
// 
//  Place stone on node 4 (weight = 4). 
//  Place stone on node 3 (weight = 8). 
//  Remove stone from node 4 (weight = 4). 
//  Place stone on node 2 (weight = 6). 
//  Place stone on node 1 (weight = 8). 
//  Remove stone from node 2 (weight = 6). 
//  Place stone on node 0 (weight = 7). 
// 
// 
// The maximum weight over all states is 8. It can be shown there is no other sequence of moves that has a smaller maximum weight.
// 
// 1)
// {0,0}
// {1,2,3}
// 
// Returns: 6
// 
// In order to be able to place a stone onto node 0 we have to place stones onto both of its children. Thus, at the end of the game each of these three nodes will have a stone.
// 
// 
// 2)
// {0}
// {100000,100000}
// 
// Returns: 200000
// 
// 
// 
// 3)
// {0,0,1,1,2,2}
// {1,1,1,1,1,1,1}
// 
// Returns: 4
// 
// 
// 
// 4)
// {0,0,1,2,3,4,4,2,1,3,6,7}
// {1,2,3,4,5,6,6,7,8,8,8,9,10}
// 
// Returns: 22
// 
// 
// 
// END KAWIGIEDIT TESTING

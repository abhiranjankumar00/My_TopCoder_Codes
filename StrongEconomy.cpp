#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class StrongEconomy
{
public:
	long long earn(long long n, long long k, long long price, long long target);
};

bool check(int64 period, int64 n, int64 k, int64 price, int64 target) {
	int64 curMoney = 0;

	while(period > 0) {
		if(curMoney >= target)
			return true;	

		int64 remMoney = target - curMoney;
		int64 w = (remMoney / n )/ k + ((remMoney % n == 0 && (remMoney/n) % k == 0) ? 0 : 1);
		if(w <= period)
			return true;

		w = (price / n) / k + (( price % n == 0 && (price/n)%k ) == 0 ? 0 : 1);
		period -= w;
		curMoney += (w*n*k - price);

		if(n <= k)
			n++;
		else
			k++;
	}
	if(period == 0 && curMoney >= target)
		return true;
	return false;
}

int64 binarySearch(int64 l, int64 r, int64 n, int64 k, int64 price, int64 target) {
	if(l == r)
		return l;
	int64 mid = (l+r)/2;
	bool flag = check(mid, n, k, price, target);

	Pf("period = %lld, n = %lld, k = %lld, price = %lld, target = %lld: %s\n", mid, n, k, price, target, flag ? "Yes" : "No");
	if(flag)
		return binarySearch(l, mid, n, k, price, target);
	else
		return binarySearch(mid+1, r, n, k, price, target);
}

long long StrongEconomy::earn (long long n, long long k, long long price, long long target) 
{
	return binarySearch(1, 1e12+12, n, k, price, target);
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, long long p1, long long p2, long long p3, bool hasAnswer, long long p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3;
	cout << "]" << endl;
	StrongEconomy *obj;
	long long answer;
	obj = new StrongEconomy();
	clock_t startTime = clock();
	answer = obj->earn(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	long long p0;
	long long p1;
	long long p2;
	long long p3;
	long long p4;
	
	{
	// ----- test 0 -----
	p0 = 2ll;
	p1 = 1ll;
	p2 = 2ll;
	p3 = 10ll;
	p4 = 4ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 2ll;
	p1 = 1ll;
	p2 = 2ll;
	p3 = 9ll;
	p4 = 3ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 1ll;
	p1 = 1ll;
	p2 = 500000ll;
	p3 = 1000002ll;
	p4 = 1000001ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 5ll;
	p1 = 4ll;
	p2 = 15ll;
	p3 = 100ll;
	p4 = 5ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// As a serious strategy-games player, you know how important it is for your country to have a strong economy.  In order to make this happen, you've just built n factories and hired k specialists.  Unfortunately, you now have no gold left, and you must figure out the fastest way to raise target units of gold.
// In a single round, you earn F*S units of gold, where F is the number of factories and S is the number of specialists you currently have.  At the end of each round, you can build more factories and hire more specialists.  Building one new factory or hiring one new specialist costs price units of gold.  As long as you can afford them, there is no limit to the number of factories and specialists you have.  Return the minimum number of rounds required to earn at least target units of gold.
// 
// DEFINITION
// Class:StrongEconomy
// Method:earn
// Parameters:long long, long long, long long, long long
// Returns:long long
// Method signature:long long earn(long long n, long long k, long long price, long long target)
// 
// 
// CONSTRAINTS
// -n, k, price and target will each be between 1 and 10^12, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 1
// 2
// 10
// 
// Returns: 4
// 
// In the first round you will earn 2*1 = 2 units of gold and must spend them on hiring a new specialist. In each of the rounds that follow, you will earn 2*2 = 4 units of gold. You need 3 more rounds in order to earn at least 10 units of gold.
// 
// 1)
// 2
// 1
// 2
// 9
// 
// Returns: 3
// 
// In the first round you will earn 2*1 = 2 units of gold and must spend them on hiring a new specialist. In the second round you will earn 2*2 = 4 units of gold and must spend them on building a factory and hiring another specialist. In the third round you will earn 3*3 = 9 units of gold.
// 
// 2)
// 1
// 1
// 500000
// 1000002
// 
// Returns: 1000001
// 
// Wait 500000 rounds in order to earn 500000*1*1 = 500000 units of gold. At the end of the 500000th round, spend all your money to build a factory (or to hire a specialist). In each of the rounds that follow, you will earn 2*1 = 2 units of gold, so you need 500001 more rounds in order to earn the required 1000002 units of gold.
// 
// 3)
// 5
// 4
// 15
// 100
// 
// Returns: 5
// 
// Don't spend your gold at all.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

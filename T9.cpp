#include <bits/stdc++.h>
using namespace std;

class T9
{
public:
	string message(vector <string> part, vector <string> dict, vector <string> keystr);
};

string T9::message (vector <string> part, vector <string> dict, vector <string> keystr) 
{
	map<string, vector <string> > mp;
	map<char, int> idx;
	for(int i = 0; i < part.size(); ++i) {
		if(part[i].size() == 0)
			idx[' '] = i;
		else 
			for(auto it = (part[i]).begin(); it != (part[i]).end(); ++it) 
				idx[*it]=i;
	}
	/*
	for(auto it = (idx).begin(); it != (idx).end(); ++it) {
		printf("%c: %d, ", it->first, it->second);
	}
	cout << "\n";
	cout << "\n";
	*/
	for(auto it = (dict).begin(); it != (dict).end(); ++it) {
		string st = *it;
		string tmp = "";
		for(int i = 0; i < st.size(); ++i) {
			tmp += (char)(idx[st[i]]+'1');
		}
		mp[tmp].push_back(st);
	//	cout << *it << ": " << tmp <<  "\n";
	}
	for(auto it = (mp).begin(); it != (mp).end(); ++it) {
		sort((it->second).begin(), (it->second).end());
	}
	string sentence = "";
	for(auto it = (keystr).begin(); it != (keystr).end(); ++it) {
		sentence += *it;
	}
	for(int i = 0; i < sentence.size(); ++i) {
		if(sentence[i] == '0')	
			sentence[i] = ' ';
	}
	/*
	cout << "\n";
	cout << "sentence = |" << sentence << "|\n";
	cout << "\n";

	for(auto it = (mp).begin(); it != (mp).end(); ++it) {
		cout << it->first << ": " ;
		for(auto jt = (it->second).begin(); jt != (it->second).end(); ++jt) {
			cout << *jt << ", ";
		}
		cout << "\n";
		cout << "\n";
	}
	cout << "\n";
	*/
	string ret = "";

	for(int i = 0; i < sentence.size(); ) {
		if(sentence[i] == ' ') {
			ret += ' ';
			i++;
			continue;
		}
		string cur = "";
		int cnt = 0;
		while(i < sentence.size() && sentence[i] != ' ') {
			if(sentence[i] >= '1' && sentence[i] <= '9')
				cur += sentence[i];
			else if(sentence[i] == '*')
				cnt+=5;
			else
				cnt++;
			i++;
		}
		//cout << "cur = |" << cur << "|\n";
		//cout << "cnt = " << cnt << "\n";
		ret += mp[cur][cnt];
	}
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, vector <string> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p2[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	T9 *obj;
	string answer;
	obj = new T9();
	clock_t startTime = clock();
	answer = obj->message(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	vector <string> p2;
	string p3;
	
	{
	// ----- test 0 -----
	string t0[] = {"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"bad"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"2230223"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "bad bad";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"the","tie"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"0843#000843#000"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = " tie   tie   ";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"bad","ace","aad","aae","aaf","acf","acd","the","tie"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"223#02","23*#00843#0"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "aae bad  tie ";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"the","tie","bad","ace","aad","aae","aaf","acf","acd"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"84300223#02","23#*"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "the  aae bad";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"bad","ace","aad","aae","tie","aaf","acf","acd","the"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"223#02","23######"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "aae bad";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"","rq","lde","yoauz","cbfgn","tjkpx","wvs","ih","m"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"xktgmfmoqlmivm","hmthr","tpjgmnmaremiwm","tpjcmnmyrlmhvm","xkpnmgmzqdmhsm","wqopvvmiig","melbcbqeeg","jkxnmbmardmhwm","kpxnmcmyqlmism","wrztvsmhhf","srztssmiic","pxtgmfmyrdmhwm","vqoxswmiin","wryksvmihb","ptjfmbmoremhvm"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"00","7246779885##00000089682000007246779885##0000724677","9885#000089682000093355523350066659594239879###000"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "  wqopvvmiig      hmthr     wqopvvmiig    vqoxswmiin    hmthr    melbcbqeeg  pxtgmfmyrdmhwm   ";
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The old fashioned king does not know how to SMS and thus he is having problems sending messages to the queen. In particular, he is having a problem with a feature called T9.
// 
// In T9, the set of alphabets are partitioned into 9 sets, where the i-th set of characters (1-based) denotes the possible characters that may be typed by pressing digit i. For this problem, we will use strings to denote a set of characters. On a standard modern cell phone, the following partition is used
// 
// 	{"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// 
// For the partition above, pressing 2 may output 'a', 'b' or 'c'; pressing 3 may output 'd', 'e' or 'f'; and so on. Pressing 223 can give you various outputs of the form "(abc)(abc)(def)" where (XYZ) means that the letter can be either X or Y or Z. For example, a few possible outputs are "ace", "bad" and "bbe".
// 
// However, not all possible outputs are dictionary words (like "bbe" is not a dictionary word), and thus these outputs do not make sense. The cell phone considers only those outputs which correspond to dictionary words. Suppose that there are only two possible dictionary words from "(abc)(abc)(def)" - namely, "ace" and "bad". Then, the keystrokes 223 gives the output "ace", and the keystrokes 223# gives the output "bad". In general if a certain number (like 223) corresponds to multiple dictionary words, then the number followed by n hashes ('#') is used to type the n-th dictionary word (0-based) from the lexographically sorted list of dictionary words corresponding to the number. Sometimes the number of hashes typed can be quite large. Hence, we have a special character star ('*') which is equivalent to 5 contiguous hashes. The digit 0 is used to type a space.
// 
// The king needs to type a text using T9. The text is a string that consists of lowercase letters ('a'-'z') and space characters (' '). A word is a maximal contiguous substring of the text that contains only lowercase letters ('a'-'z'). The only way the king can type a word is by first pressing a non-empty sequence of digits ('1'-'9') followed by a (possibly emtpy) sequence of characters '#' and/or '*'.
// 
// You will be given a vector <string> part whose i-th element (1-based) is the set of alphabets which correspond to the digit i. You will also be given a vector <string> dict that represents a set of all dictionary words, where each element is a single word. Finally, you will be given a vector <string> keystr. Concatenate the elements of keystr in the same order as they are given to obtain a string. This string represents the keystrokes pressed by the king. To help the king, return the text that will result when the given keystrokes are pressed. You may assume that the given keystrokes are valid, i.e. each maximal contiguous substring that doesn't contain '0' characters starts from non-empty sequence of digits ('1'-'9') and then is optionally continued with a sequence of '#' and/or '*' characters. You may also assume that each such substring corresponds to a word from dict.
// 
// DEFINITION
// Class:T9
// Method:message
// Parameters:vector <string>, vector <string>, vector <string>
// Returns:string
// Method signature:string message(vector <string> part, vector <string> dict, vector <string> keystr)
// 
// 
// NOTES
// -A substring of a string is called maximal with respect to some property if it can't be extended to the left or to the right while maintaining the property.
// -A string A is lexicographically less than another string B of the same length if there exists a position i such that each character of A before the i-th position is equal to the character at the corresponding position in B, and A[i] is less than B[i].
// -For the purpose of this problem, a partition of alphabets into 9 sets may contain any number of empty sets.
// 
// 
// CONSTRAINTS
// -part will represent a valid partition of the 26 english alphabets into 9 sets, i.e. it will consist of exactly 9 elements and every letter from 'a' to 'z' will appear exactly once in exactly one of the elements of part.
// -dict will contain between 1 and 50 elements, inclusive.
// -Each element of dict will contain between 1 and 50 characters, inclusive.
// -Each character in dict will be a lowercase letter 'a'-'z'.
// -All elements of dict will be distinct.
// -keystr will contain between 1 and 50 elements, inclusive.
// -Each element of keystr will contain between 1 and 50 characters, inclusive.
// -Each character in keystr will be one of '0'-'9', '#', '*'.
// -The length of the resulting text will be between 1 and 1000, inclusive.
// -The string obtained by concatenating the elements of keystr will represent a valid sequence of keystrokes (as explained in the statement).
// 
// 
// EXAMPLES
// 
// 0)
// {"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// {"bad"}
// {"2230223"}
// 
// Returns: "bad bad"
// 
// 1)
// {"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// {"the", "tie"}
// {"0843#000843#000"}
// 
// Returns: " tie   tie   "
// 
// There may be leading, trailing and contiguous spaces.
// 
// 2)
// {"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// {"bad", "ace", "aad", "aae", "aaf", "acf", "acd", "the", "tie"}
// {"223#02", "23*#00843#0"}
// 
// Returns: "aae bad  tie "
// 
// Don't forget to concatenate the elements of keystr. Also, "*" is equivalent to "#####".
// 
// 3)
// {"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// {"the", "tie", "bad", "ace", "aad", "aae", "aaf", "acf", "acd"}
// {"84300223#02", "23#*"}
// 
// Returns: "the  aae bad"
// 
// '*' may also appear after the '#'. All that matters is, it is equivalent to "#####".
// 
// 4)
// {"", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
// {"bad", "ace", "aad", "aae", "tie", "aaf", "acf", "acd", "the"}
// {"223#02", "23######"}
// 
// Returns: "aae bad"
// 
// The king may use '*'. But it is not necessary that he uses it everytime he is allowed to use it. 
// 
// 5)
// {"", "rq", "lde", "yoauz", "cbfgn", "tjkpx", "wvs", "ih", "m"}
// {"xktgmfmoqlmivm", 
//  "hmthr", 
//  "tpjgmnmaremiwm", 
//  "tpjcmnmyrlmhvm", 
//  "xkpnmgmzqdmhsm", 
//  "wqopvvmiig", 
//  "melbcbqeeg", 
//  "jkxnmbmardmhwm", 
//  "kpxnmcmyqlmism", 
//  "wrztvsmhhf", 
//  "srztssmiic", 
//  "pxtgmfmyrdmhwm", 
//  "vqoxswmiin", 
//  "wryksvmihb", 
//  "ptjfmbmoremhvm"}
// {"00", 
//  "7246779885##00000089682000007246779885##0000724677", 
//  "9885#000089682000093355523350066659594239879###000"}
// 
// Returns: "  wqopvvmiig      hmthr     wqopvvmiig    vqoxswmiin    hmthr    melbcbqeeg  pxtgmfmyrdmhwm   "
// 
// 
// 
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

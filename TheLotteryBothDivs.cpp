#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back
#define	SZ(a)	int((a).size())

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define	forn(i, n)	for(int i = 0; i < n; i++)
#define	forab(i, a, b)	for(int i = a; i <= b; i++)
#define	rep(i, a, b)	for(int i = a; i>=b; i--)

class TheLotteryBothDivs
{
	bool vis[100];

	bool IsSuffix(ST a, ST b) {

		if(a.length() < b.length())	return false;
	 	ST s = 	a.substr(a.length() - b.length());

		//cout << s << " - " << b << endl;

		if(s == b)	return true;

		return false;
	}

public:
	double find(vector <string> goodSuffixes)
	{

		forn(i, 100)	vis[i] = true;

		sort(all(goodSuffixes));

		goodSuffixes.resize(unique(all(goodSuffixes)) - goodSuffixes.begin());

		int64 tot = 999999999+1;
		double ret = 0.0;
		int64 cnt = 0, tmp = 0;

		forn(i, SZ(goodSuffixes))	forn(j, SZ(goodSuffixes))	if(i != j)
			if(IsSuffix(goodSuffixes[i], goodSuffixes[j]))
				vis[i] = false;
/*
		forn(i, SZ(goodSuffixes))	
			cout << goodSuffixes[i] << " : " << (vis[i] ? 1 : 0 ) << endl;
*/
		tr(it, goodSuffixes) 
//		forn(i, SZ(goodSuffixes))
		{
			if(vis[ it - goodSuffixes.begin() ] == false)	continue;
			tmp = 1;
			forab(i, it->length(), 8)
//			forab(i, goodSuffixes[i].length() , 8)
				tmp *= 10;
			cnt += tmp;
		}
		ret = cnt*1.0/tot;
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, double p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	TheLotteryBothDivs *obj;
	double answer;
	obj = new TheLotteryBothDivs();
	clock_t startTime = clock();
	answer = obj->find(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p1 - answer) <= 1e-9 * max(1.0, fabs(p1));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	double p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"4"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0.1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"4","7"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0.2;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"47","47"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0.01;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"47","58","4747","502"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0.021;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"8542861","1954","6","523","000000000","5426","8"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0.201100101;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Farmer John wants to buy a lottery ticket. Before he buys a ticket, Fox Brus decided to calculate the probability that John will get a prize.
// 
// 
// There are 1,000,000,000 types of lottery tickets. They are numbered "000000000" to "999999999" (they may have leading zeroes). Each type of ticket has an equal probability of being bought by John. You are given a vector <string> goodSuffixes. If the number written on John's ticket has at least one element of goodSuffixes as a suffix, he will get a prize.
// 
// 
// Return the probability that John will get a prize.
// 
// DEFINITION
// Class:TheLotteryBothDivs
// Method:find
// Parameters:vector <string>
// Returns:double
// Method signature:double find(vector <string> goodSuffixes)
// 
// 
// NOTES
// -The returned value must have an absolute or relative error less than 1e-9.
// -A suffix of a string is obtained by removing zero or more contiguous characters from the beginning of the string.
// 
// 
// CONSTRAINTS
// -goodSuffixes will contain between 1 and 50 elements, inclusive.
// -Each element of goodSuffixes will contain between 1 and 9 characters, inclusive.
// -Each character in goodSuffixes will be a digit ('0'-'9').
// 
// 
// EXAMPLES
// 
// 0)
// {"4"}
// 
// Returns: 0.1
// 
// John will get a prize if the last digit is '4'. It happens with probability 0.1.
// 
// 1)
// {"4", "7"}
// 
// Returns: 0.2
// 
// 
// 
// 2)
// {"47", "47"}
// 
// Returns: 0.01
// 
// goodSuffixes may contain duplicate elements.
// 
// 3)
// {"47", "58", "4747", "502"}
// 
// Returns: 0.021
// 
// 
// 
// 4)
// {"8542861", "1954", "6", "523", "000000000", "5426", "8"}
// 
// Returns: 0.201100101
// 
// 
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

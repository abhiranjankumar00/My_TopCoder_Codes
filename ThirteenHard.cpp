#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	CL(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0 or defined ONLINE_JUDGE)
	#define DEBUG
#else 
	#define DEBUG(x)	cout << #x << " = " << x << "\n"
#endif

class ThirteenHard
{
public:
	int calcTime(vector <string> city);
};

int ThirteenHard::calcTime (vector <string> city) 
{
	int ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	ThirteenHard *obj;
	int answer;
	obj = new ThirteenHard();
	clock_t startTime = clock();
	answer = obj->calcTime(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"#AB##","###A#","###C#","####K","#####"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 16;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"#Z","Z#"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"Good#####","#Luck####","##and####","##Have###","####Fun##","#####in##","#####the#","CHALLENGE","##PHASE##"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 137;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"###No#####","####Zaphod","#####Just#","######very","####very##","improbable","##########","##########","##########","##########"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 103;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"#B#C##T#M","##K######","########A","####R####","#####U###","########C","#######H#","########S","#########"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 47;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Despite being beautiful, funny and intelligent (or at least she thinks so), Elleonora has one great disadvantage – she is really superstitious. Although at first sight this seems to be a small thing, it influences great parts of her life. For example, planning an evening out with her friends is quite a challenge for Elly.
// 
// While travelling somewhere Elly counts the minutes passed since the time she left home and insists on arriving everywhere such that the time for any segment of her trip is not divisible by 13, since 13 is believed to be one of the most fatal numbers. Here, a segment of the trip refers to any consecutive sequence of transports used by Elly. This means that if her path is home -> station1 -> station2 -> destination with travel times home -> station1 = T1, station1 -> station2 = T2 and station2 -> destination = T3 then none of T1, T2, T3, T1 + T2, T2 + T3 and T1 + T2 + T3 should be divisible by 13.
// 
// For example, let the durations of the transports Elly uses be 7, 10 and 16 minutes, respectively. Then, the segment with transports 2 and 3 has a total duration of 10 + 16 = 26 minutes, which is divisible by thirteen and this will ruin her day. On the other hand if the segments of her travel were with durations 7, 14 and 16 minutes, then none of the numbers 7, 14, 16, 21, 30 or 37 would be divisible by thirteen, so this would be a valid path.
// 
// There are N stations numbered 0 to N-1 in the city where Elly lives. There are transports between some stations and they are described in vector <string> city containing exactly N elements. The j-th character in i-th element of city describes the duration of the transport that goes directly from station i to station j. Durations of 1, 2, ..., 26 are encoded with 'A', 'B', ..., 'Z', correspondingly, and durations of 27, 28, ..., 52 are encoded with 'a', 'b', ..., 'z', correspondingly. If there is no transport going directly from station i to station j, the corresponding character will be '#'. All transports are directed, so if there's a transport from station i to station j, there will not necessarily be a transport from station j to station i, and if there's such a transport, it will not necessarily be of the same duration. For each station, there can be a transport from this station to itself.
// 
// Elly wants to reach station N-1 (0-based) starting from station 0 and using one or more transports. More formally, her path is a sequence of stations S[0], S[1], ..., S[k], k ≥ 1, where S[0] = 0, S[k] = N-1 and for each i, 0 ≤ i < k, there's a direct transport from S[i] to S[i+1]. The same station can appear several times in her path. If T[i], 0 ≤ i < k, is the duration of the transport from S[i] to S[i+1] in minutes, then there must not be any indices  i, j, 0 ≤ i ≤ j < k, such that T[i] + T[i+1] + ... + T[j] is divisible by 13.
// 
// Return the minimum time in which she can reach station N-1 while respecting her superstitious requirements. If this is not possible, return -1.
// 
// DEFINITION
// Class:ThirteenHard
// Method:calcTime
// Parameters:vector <string>
// Returns:int
// Method signature:int calcTime(vector <string> city)
// 
// 
// CONSTRAINTS
// -city will contain exactly N elements, where N is between 2 and 25, inclusive.
// -Each element of city will contain exactly N characters.
// -Each element of city will contain only the characters 'a'-'z', 'A'-'Z' and '#'.
// 
// 
// EXAMPLES
// 
// 0)
// { "#AB##",
//   "###A#",
//   "###C#",
//   "####K",
//   "#####" }
// 
// Returns: 16
// 
// Here the shortest path is with length 13, but that makes it forbidden. The second shortest path is with length 16 and is OK.
// 
// 1)
// { "#Z",
//   "Z#" }
// 
// Returns: -1
// 
// Here the only path is impossible.
// 
// 2)
// { "Good#####",
//   "#Luck####",
//   "##and####",
//   "##Have###",
//   "####Fun##",
//   "#####in##",
//   "#####the#",
//   "CHALLENGE",
//   "##PHASE##" }
// 
// Returns: 137
// 
// Good luck and have fun in the challenge phase.
// 
// 3)
// { "###No#####",
//   "####Zaphod",
//   "#####Just#",
//   "######very",
//   "####very##",
//   "improbable",
//   "##########",
//   "##########",
//   "##########",
//   "##########" }
// 
// Returns: 103
// 
// You can use random messages as challenges.
// 
// 4)
// { "#B#C##T#M",
//   "##K######",
//   "########A",
//   "####R####",
//   "#####U###",
//   "########C",
//   "#######H#",
//   "########S",
//   "#########" }
// 
// Returns: 47
// 
// Here we have four possible paths. The shortest one is 0 -> 8 and has length 13 which makes it impossible. The second shortest is 0 -> 1 -> 2 -> 8, but the segment 0 -> 1 -> 2 has length 13, which is impossible. The third one is 0 -> 3 -> 4 -> 5 -> 8, which has length 45, but the segment 3 -> 4 -> 5 is of length 39, which is divisible by 13 and makes it impossible. The fourth one 0 -> 6 -> 7 -> 8 is possible and has length 47.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

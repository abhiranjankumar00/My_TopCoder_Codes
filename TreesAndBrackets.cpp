#include <bits/stdc++.h>
using namespace std;

vector<string> getChildren(string str) {
	vector<string> ret;
	for(int l = 0, r = 0, cnt = 0; r < (int)str.size(); r++) {
		cnt += (str[r] == '(' ? 1 : -1);
		if(cnt == 0) {
			ret.push_back(str.substr(l, r-l+1));
			l = r+1;
		}
	}
	return ret;
}

class Node {
  public:
	vector<Node*> children;
};

Node* createTree(string s) {
	if(s.empty())
		return nullptr;

	Node* root = new Node();
	auto cs = s.substr(1, s.length()-2);

	auto children = getChildren(cs);

	/*
	printf("s = '%s', cs = '%s', children: [", s.c_str(), cs.c_str());
	for(auto c: children)
		printf("'%s' ", c.c_str());
	cout << "]" << endl;
	*/

	for(auto c: children) {
		auto cptr = createTree(c);
		if(cptr != nullptr)
			root->children.push_back(cptr);
	}
	return root;
}

string toString(Node *nd) {
	if(nd == nullptr)
		return "";
	string ret = "(";
	for(auto ch: nd->children)
		ret += toString(ch);
	ret += ")";
	return ret;
}

bool overlaps(Node *base, Node *oth) {
	if(oth == nullptr)
		return true;
	if(base == nullptr)
		return false;


	int bChildCnt = base->children.size();
	int bIdx = 0;
	//string output = "NO";

	for(auto oChild: oth->children) {
		if(bIdx >= bChildCnt) {
			//printf("%16s -> %-16s : %s\n", toString(base).c_str(), toString(oth).c_str(), output.c_str());
			return false;
		}

		for(; bIdx < bChildCnt && not overlaps(base->children[bIdx], oChild); bIdx++);
		if(bIdx == bChildCnt) {
			//printf("%16s -> %-16s : %s\n", toString(base).c_str(), toString(oth).c_str(), output.c_str());
			return false;
		}

		bIdx++;
	}

	/*
	output = "YES";
	printf("%16s -> %-16s : %s\n", toString(base).c_str(), toString(oth).c_str(), output.c_str());
	printf("bIdx = %d, cChildCnt = %d\n", bIdx, bChildCnt);
	*/
	return true;
}

class TreesAndBrackets
{
public:
    string check(string t1, string t2)
    {
		Node* tree1 = createTree(t1);
		Node* tree2 = createTree(t2);

		assert(t1 == toString(tree1));
		assert(t2 == toString(tree2));

        string success = "Possible", fail = "Impossible";
		return overlaps(tree1, tree2) ? success : fail;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	TreesAndBrackets *obj;
	string answer;
	obj = new TreesAndBrackets();
	clock_t startTime = clock();
	answer = obj->check(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	string p0;
	string p1;
	string p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = "(())";
	p1 = "()";
	p2 = "Possible";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = "()";
	p1 = "()";
	p2 = "Possible";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = "(()()())";
	p1 = "((()))";
	p2 = "Impossible";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = "((())((())())())";
	p1 = "(()(())())";
	p2 = "Possible";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = "((())((())())())";
	p1 = "((()()()()()))";
	p2 = "Impossible";
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// This problem is about rooted trees in which the order of children matters.
// This type of trees is easily encoded using correct bracket sequences.
// The code of a tree rooted at r is constructed as follows:
// 
// Write down the opening bracket '('.
// For each child c of r, in order, write down the code of the subtree rooted at c.
// Write down the closing bracket ')'.
// 
// 
// For example, the code of a three-vertex tree in which the root has two children is "(()())".
// 
// You are given the strings t1 and t2 that represent two rooted trees using the encoding defined above.
// You want to transform t1 into t2.
// 
// 
// The only operation you are allowed to perform is to remove a leaf from t1.
// (A leaf is a vertex with no children.)
// Note that removing the child of a parent does not change the relative order of the other children of that same parent.
// 
// 
// Return "Possible" if there is a sequence of zero or more operations that transforms t1 into t2.
// Otherwise, return "Impossible".
// 
// DEFINITION
// Class:TreesAndBrackets
// Method:check
// Parameters:string, string
// Returns:string
// Method signature:string check(string t1, string t2)
// 
// 
// CONSTRAINTS
// -t1 and t2 will contain between 2 and 100 characters, inclusive.
// -Each character in t1 and t2 will be either '(' or ')'.
// -Both t1 and t2 will represent a correct tree.
// 
// 
// EXAMPLES
// 
// 0)
// "(())"
// "()"
// 
// Returns: "Possible"
// 
// 
// 
// 1)
// "()"
// "()"
// 
// Returns: "Possible"
// 
// 
// 
// 2)
// "(()()())"
// "((()))"
// 
// Returns: "Impossible"
// 
// Currently t1 is a tree of depth 2 in which the root has three children, while t2 is a tree of depth 3.
// Clearly, you cannot increase the depth of a tree by removing some of its vertices.
// 
// 3)
// "((())((())())())"
// "(()(())())"
// 
// Returns: "Possible"
// 
// 
// 
// 4)
// "((())((())())())"
// "((()()()()()))"
// 
// Returns: "Impossible"
// 
// 
// 
// END KAWIGIEDIT TESTING

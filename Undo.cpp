#include <iostream>
#include <ctime>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cassert>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long 		int64;
typedef vector<int> 		vi;
typedef string 			ST;
typedef stringstream 		SS;
typedef vector< vector<int> > 	vvi;
typedef pair<int,int> 		ii;
typedef vector<string> 		vs;
/*
#if __cplusplus > 199711L	// for g++0x, value of __cplusplus must be greater thana 199711L.
	#define tr(i, c)	for(auto i = begin(c); i != end(c); i++)
#else
	#define tr(i, c)	for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#endif
*/
#define endl		("\n")
#define tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define PI		M_PI
#define E 		M_E
#define	eps		1e-9

#define	Sf		scanf
#define	Pf		printf

#define forn(i, n)	for(int i = 0, lets_stop_here = (int)n; i <  lets_stop_here; i++)
#define forab(i, a, b)	for(int i = a, lets_stop_here = (int)b; i <= lets_stop_here; i++)
#define rep(i, a, b)	for(int i = a, lets_stop_here = (int)b; i >= lets_stop_here; i--)

#define	all(c)		(c).begin(), (c).end()
#define	cl(a, b)	memset(a, b, sizeof(a))
#define mp		make_pair
#define pb		push_back

#define	present(x, c)	((c).find(x) != (c).end())	//map & set//
#define	cpresent(x, c)	(find( (c).begin(), (c).end(), x) != (c).end())	//vector & list//

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

#if (0)
	#define debug 
#else 
	#define debug(x)	cout << #x << " = " << x << "\n"
#endif

class Undo
{
public:
	string getText(vector <string> commands, vector <int> time);
};
//SRM419
string Undo::getText (vector <string> commands, vector <int> time) 
{
	string ret = "";
	int N = time.size() ;
	vector <bool> in(N, true );

	for(int t = N-1; t >= 0; t--) if(in[t] == true){
		if(commands[t][0] == 'u') {
			int tm = atoi(commands[t].substr(5).c_str());
			tm = time[t] - tm;
			cout << "tm = " << tm << "\n";  

			for(int tt = 0; tt < t; tt++) 
				if(time[tt] >= tm)
					in[tt] = false;
		}
	}

	for(int t = 0; t < N; t++) if(in[t] && commands[t][0] == 't') {
		ret += commands[t][5];
	}

	for(__typeof(in.begin()) it = in.begin(); it < in.end(); it++)
		cout << *it << " ";
	cout << "\n";
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <int> p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	Undo *obj;
	string answer;
	obj = new Undo();
	clock_t startTime = clock();
	answer = obj->getText(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <int> p1;
	string p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"type a","type b","type c","undo 3"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "a";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"type a","type b","undo 2","undo 2"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "a";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"type a","undo 1","undo 1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "a";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"type a","type b","type c","undo 10"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,1000};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "abc";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"undo 1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = "";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are writing a simple text editor that supports only the following two commands: 
// 
// "type c" where c is a character: Append character c to the end of the current text.
// "undo t" where t is an integer: Undo all operations that were performed in the previous t seconds in reverse order.
// 
// 
// 
// All quotes are for clarity only.  The text in the editor is initially empty.
// 
// 
// For example, consider the following sequence of commands:
// 
// 
// Second 1: type a
// Second 2: type b
// Second 3: type c
// Second 5: undo 3
// 
// 
// At the end of second 3, the text is "abc".  At second 5, all commands performed in the previous 3 seconds are undone in reverse order.  This means 'c' is removed, and then 'b' is removed.  The text becomes just "a".
// 
// 
// Note that "undo" commands can also be undone.  For example:
// 
// 
// Second 1: type a
// Second 2: type b
// Second 3: undo 2
// Second 4: undo 2
// 
// 
// After second 2, the text is "ab".  After second 3, everything is undone, and the text becomes empty.  At second 4, the previous "undo" is undone, so the text becomes "ab" again.  Then, the "type b" is also undone and the text becomes just "a".
// 
// 
// You are given a vector <string> commands and a vector <int> time.  Each element of commands is a single command, and commands[i] is performed at time[i].  The commands are given in chronological order.  Return the text after all the commands are executed.
// 
// 
// DEFINITION
// Class:Undo
// Method:getText
// Parameters:vector <string>, vector <int>
// Returns:string
// Method signature:string getText(vector <string> commands, vector <int> time)
// 
// 
// CONSTRAINTS
// -commands will contain between 1 and 50 elements, inclusive.
// -Each element of commands will be either "type c" where c is a lowercase letter ('a'-'z') or "undo t" where t is an integer between 1 and 10^9, inclusive, with no leading zeroes (quotes for clarity only).
// -time will contain the same number of elements as commands.
// -Each element of time will be between 1 and 10^9, inclusive.
// -The elements of time will be in strictly ascending order.
// 
// 
// EXAMPLES
// 
// 0)
// {"type a", "type b", "type c", "undo 3"}
// {1, 2, 3, 5}
// 
// Returns: "a"
// 
// The first example from the problem statement.
// 
// 1)
// {"type a", "type b", "undo 2", "undo 2"}
// {1,2,3,4}
// 
// Returns: "a"
// 
// The second example from the problem statement.
// 
// 2)
// {"type a", "undo 1", "undo 1"}
// {1,2,3}
// 
// Returns: "a"
// 
// 
// 
// 3)
// {"type a", "type b", "type c", "undo 10"}
// {1, 2, 3, 1000}
// 
// Returns: "abc"
// 
// Note that "undo" can undo nothing if it is too late.
// 
// 4)
// {"undo 1"}
// {1}
// 
// Returns: ""
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

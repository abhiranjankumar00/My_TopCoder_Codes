#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
#include <iterator>
#include <fstream>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define DEBUG(x)	cout << #x << " = " << x << "\n"
#define endl 		("\n")

#define	ep		1e-9
#define PI		M_PI
#define E 		M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp		make_pair
#define	pb		push_back

#define	all(c)		(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())		//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here ; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int)b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i >= loop_ends_here; i--)

#define Pf		printf
#define	Sf		scanf

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

/*
#ifdef DEBUG
	#undef DEBUG
#endif
#define DEBUG
*/

class UnionOfIntervals
{
public:
	int nthElement(vector <int> lowerBound, vector <int> upperBound, int n);
};

vector <int64> lowerBound, upperBound;
int64 N;

int64 numLessThan(int n) {
	int64 ret = 0;
	
	forn(i, lowerBound.size()) {
		if(lowerBound[i] > n)
			ret += 0;
		else if(upperBound[i] < n )
			ret += upperBound[i] - lowerBound[i] + 1;
		else
			ret += n - lowerBound[i];
	}
	return ret;
}

int64 solve(int64 l = *min_element(all(lowerBound)), int64 r = *max_element(all(upperBound))) {
	if(l == r)
		return l;
	int64 mid = (l+r+1)/2;

	if(numLessThan(mid) > N) 
		return solve(l, mid-1);
	else
		return solve(mid, r);
}

int UnionOfIntervals::nthElement (vector <int> lowerBound, vector <int> upperBound, int n) 
{
	N = (int64)n;
	::lowerBound.clear(), ::upperBound.clear();
	forn(i, lowerBound.size()) {
		::lowerBound.pb(lowerBound[i]);
		::upperBound.pb(upperBound[i]);
	}
	return (int)solve();
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	UnionOfIntervals *obj;
	int answer;
	obj = new UnionOfIntervals();
	clock_t startTime = clock();
	answer = obj->nthElement(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	int t0[] = {1,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {3,7};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4;
	p3 = 6;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {4,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	p3 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {-1500000000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1500000000};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1500000091;
	p3 = 91;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Given a list of integers, find the n-th smallest number, i.e., the number that appears at index n (0-based) when they are sorted in non-descending order. The numbers will be given in intervals. For example, the intervals (1, 3) and (5, 7) represent the list of numbers { 1, 2, 3, 5, 6, 7 }. A number may be present in more than one interval, and it appears in the list once for each interval it is in. For example, the intervals (1, 4) and (3, 5) represent the list of numbers { 1, 2, 3, 3, 4, 4, 5 }.
// 
// The intervals will be given as two vector <int>s, lowerBound and upperBound. The i-th elements of these vector <int>s represent the smallest and largest numbers in the i-th interval, inclusive.
// 
// DEFINITION
// Class:UnionOfIntervals
// Method:nthElement
// Parameters:vector <int>, vector <int>, int
// Returns:int
// Method signature:int nthElement(vector <int> lowerBound, vector <int> upperBound, int n)
// 
// 
// NOTES
// -n is 0-based, meaning that the first element is indexed 0.
// -A sequence is sorted in non-descending order if and only if for each pair of indices i and j, where i is smaller than j, the element at position i is less than or equal to the element at position j.
// 
// 
// CONSTRAINTS
// -lowerBound will contain between 1 and 50 elements, inclusive.
// -upperBound will contain the same number of elements as lowerBound.
// -Each element of lowerBound and upperBound will be between -2,000,000,000 and 2,000,000,000, inclusive.
// -The i-th element of lowerBound will be less than or equal to the i-th element of upperBound.
// -n will be a non-negative integer less than the total number of elements in the list, but no greater than 2,000,000,000.
// 
// 
// EXAMPLES
// 
// 0)
// { 1, 5 }
// { 3, 7 }
// 4
// 
// Returns: 6
// 
// The numbers are 1, 2, 3, 5, 6 and 7. The number at index 4 is 6.
// 
// 1)
// { 1, 3 }
// { 4, 5 }
// 3
// 
// Returns: 3
// 
// 2)
// { -1500000000 }
// { 1500000000 }
// 1500000091
// 
// Returns: 91
// 
// Watch out for overflow errors.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

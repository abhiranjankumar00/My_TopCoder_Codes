#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)


class WinningRecord
{
public:
	vector <int> getBestAndWorst(string g)
	{
		vector <int> ret;
		
		double maxper = -1, minper = 101, mxid = 0, mnid = 0;

		forab(i, 2, g.size() - 1) {
			int w = 0, l = 0;
			rep(j, i, 0)
				if(g[j] == 'W')
					w++;
				else
					l++;
			double curper = 1.0*w/(w+l);

			if(curper > maxper || abs(curper - maxper) < 1e-10) {
				maxper = curper;
				mxid = i+1;
			}

			if(curper < minper || abs(curper - minper) < 1e-10) {
				minper = curper;
				mnid = i+1;
			}
		}
		
		ret.pb(mxid);
		ret.pb(mnid);
		return ret;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	WinningRecord *obj;
	vector <int> answer;
	obj = new WinningRecord();
	clock_t startTime = clock();
	answer = obj->getBestAndWorst(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p1[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <int> p1;
	
	{
	// ----- test 0 -----
	p0 = "WWWWWLLLLLLLLLLLLLLL";
	int t1[] = {5,20};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "WWWWWW";
	int t1[] = {6,6};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "LWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLW";
	int t1[] = {50,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "WLWLWLLWWLWLWWWWWWWLWLLLLLLLLLLLLWWLWLLWWWLLLWLWLW";
	int t1[] = {19,33};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "LWWLWWLWWLLLW";
	int t1[] = {9,12};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// If a baseball team loses 15 games in a row, and then wins its next 5, there are a number of ways this could be reported.  A fan of the team could brag that they have won all 5 of their last 5 games.  However, it could also be truthfully said that they have won 5 out of their last 10 games, or only 25% of their last 20 games.
// 
// 
// Given a string results with the results of the last several games a team has played, determine how many of their most recent games to consider to find the team's worst and best percentages of winning.  Return a vector <int> with 2 elements.  The first element should be how many of the team's most recent games to consider to give their best winning record (5, in the above example).  The second element should be how many of the team's most recent games to consider to give their worst winning record (20, in the above example).
// 
// 
// The string results will contain only the characters 'W' and 'L', where 'W' indicates a win, and 'L' indicates a loss.  The left-most character represents the most recent game, and the right-most character represents the least recent game.  The string for the example above would be
// "WWWWWLLLLLLLLLLLLLLL".
// 
// 
// Never consider fewer than 3 games.  When considering 7 games (for example), they must be the 7 most recent games, not any 7 from the list.  If different numbers of games give the same winning record, choose the larger number of games.
// 
// 
// DEFINITION
// Class:WinningRecord
// Method:getBestAndWorst
// Parameters:string
// Returns:vector <int>
// Method signature:vector <int> getBestAndWorst(string games)
// 
// 
// CONSTRAINTS
// -results will contain between 3 and 50 characters, inclusive.
// -Each character of results will be either 'W' or 'L'.
// 
// 
// EXAMPLES
// 
// 0)
// "WWWWWLLLLLLLLLLLLLLL"
// 
// Returns: { 5,  20 }
// 
// This is the example from the problem statement.
// 
// 1)
// "WWWWWW"
// 
// Returns: { 6,  6 }
// 
// No matter how many games you consider, the team's winning record is 100% and the losing record is 0%.
// 
// 2)
// "LWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLWLW"
// 
// Returns: { 50,  3 }
// 
// 3)
// "WLWLWLLWWLWLWWWWWWWLWLLLLLLLLLLLLWWLWLLWWWLLLWLWLW"
// 
// Returns: { 19,  33 }
// 
// 4)
// "LWWLWWLWWLLLW"
// 
// Returns: { 9,  12 }
// 
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
